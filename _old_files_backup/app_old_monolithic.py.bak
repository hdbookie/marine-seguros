import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import google.generativeai as genai
from core import FinancialProcessor
from datetime import datetime
import os
from dotenv import load_dotenv
import json
from typing import Dict, List, Tuple
from gerenciador_arquivos import GerenciadorArquivos
from ai_chat_assistant import AIChatAssistant
from database_manager import DatabaseManager
from core.direct_extractor import DirectDataExtractor
from comparative_analyzer import ComparativeAnalyzer
from auth import init_auth, require_auth, show_login_page, show_user_menu, show_admin_panel

# Load environment variables
load_dotenv()

# Initialize authentication
init_auth()

# Initialize database manager
db = DatabaseManager()

# Page configuration
st.set_page_config(
    page_title="Marine Seguros - Financial Analytics",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
    <style>
    .main > div {
        padding-top: 2rem;
    }
    .stButton>button {
        width: 100%;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
    .category-header {
        background-color: #e1e4e8;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
        cursor: pointer;
        font-weight: bold;
    }
    .category-item {
        padding-left: 2rem;
        margin: 0.25rem 0;
    }
    .new-badge {
        background-color: #28a745;
        color: white;
        padding: 0.2rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.8rem;
        margin-left: 0.5rem;
    }
    </style>
""", unsafe_allow_html=True)

# Helper functions for data conversion (must be defined before use)
def create_period_filters(prefix, available_years, current_month=None):
    """
    Create standardized period filters for both macro and micro dashboards
    
    Args:
        prefix: String prefix for session state keys (e.g., 'macro', 'micro')
        available_years: List of available years in the data
        current_month: Current month number (1-12) for YTD calculations
        
    Returns:
        Dict with selected_years and selected_months
    """
    from datetime import datetime
    
    if current_month is None:
        current_month = datetime.now().month
    
    current_year = datetime.now().year
    
    # Initialize session state
    if f'{prefix}_year_filter' not in st.session_state:
        # Default to most recent year
        st.session_state[f'{prefix}_year_filter'] = [str(available_years[-1])] if available_years else []
    
    if f'{prefix}_month_filter' not in st.session_state:
        st.session_state[f'{prefix}_month_filter'] = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                       'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    # Time period quick filters
    st.markdown("##### ‚è±Ô∏è Per√≠odo R√°pido")
    time_cols = st.columns(6)
    
    with time_cols[0]:
        if st.button("Este Ano", key=f"{prefix}_this_year", use_container_width=True):
            current_year_str = str(current_year)
            if current_year_str in [str(y) for y in available_years]:
                st.session_state[f'{prefix}_year_filter'] = [current_year_str]
            elif available_years:  # If current year not in data, use most recent
                st.session_state[f'{prefix}_year_filter'] = [str(available_years[-1])]
            st.session_state[f'{prefix}_month_filter'] = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                          'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    with time_cols[1]:
        if st.button("Ano Passado", key=f"{prefix}_last_year", use_container_width=True):
            last_year = str(current_year - 1)
            if last_year in [str(y) for y in available_years]:
                st.session_state[f'{prefix}_year_filter'] = [last_year]
                st.session_state[f'{prefix}_month_filter'] = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                              'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    with time_cols[2]:
        if st.button("YTD", key=f"{prefix}_ytd", use_container_width=True):
            current_year_str = str(current_year)
            if current_year_str in [str(y) for y in available_years]:
                months_ytd = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                             'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ'][:current_month]
                st.session_state[f'{prefix}_year_filter'] = [current_year_str]
                st.session_state[f'{prefix}_month_filter'] = months_ytd
            elif available_years:  # If current year not in data, use most recent year
                st.session_state[f'{prefix}_year_filter'] = [str(available_years[-1])]
                st.session_state[f'{prefix}_month_filter'] = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                              'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    with time_cols[3]:
        if st.button("√öltimos 12M", key=f"{prefix}_12m", use_container_width=True):
            # Calculate last 12 months
            months_12m = []
            years_12m = []
            
            for i in range(12):
                month_idx = (current_month - 1 - i) % 12
                year_offset = (current_month - 1 - i) // 12
                calc_year = current_year - year_offset - (1 if month_idx > current_month - 1 else 0)
                
                if str(calc_year) in [str(y) for y in available_years]:
                    if str(calc_year) not in years_12m:
                        years_12m.append(str(calc_year))
                    month_name = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                 'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ'][month_idx]
                    if month_name not in months_12m:
                        months_12m.append(month_name)
            
            st.session_state[f'{prefix}_year_filter'] = years_12m
            st.session_state[f'{prefix}_month_filter'] = months_12m
    
    with time_cols[4]:
        if st.button("Q4", key=f"{prefix}_q4", use_container_width=True):
            # Default to most recent year's Q4
            if available_years:
                st.session_state[f'{prefix}_year_filter'] = [str(available_years[-1])]
                st.session_state[f'{prefix}_month_filter'] = ['OUT', 'NOV', 'DEZ']
    
    with time_cols[5]:
        if st.button("Todos", key=f"{prefix}_all", use_container_width=True):
            st.session_state[f'{prefix}_year_filter'] = [str(y) for y in available_years]
            st.session_state[f'{prefix}_month_filter'] = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                          'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    # Manual filters
    st.markdown("##### üìÖ Sele√ß√£o Manual")
    filter_cols = st.columns(2)
    
    with filter_cols[0]:
        selected_years = st.multiselect(
            "üìÖ Anos",
            options=[str(y) for y in available_years],
            default=st.session_state[f'{prefix}_year_filter'],
            key=f"{prefix}_year_multiselect"
        )
        st.session_state[f'{prefix}_year_filter'] = selected_years
    
    with filter_cols[1]:
        selected_months = st.multiselect(
            "üìÖ Meses",
            options=['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                    'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ'],
            default=st.session_state[f'{prefix}_month_filter'],
            key=f"{prefix}_month_multiselect"
        )
        st.session_state[f'{prefix}_month_filter'] = selected_months
    
    return {
        'selected_years': selected_years,
        'selected_months': selected_months
    }

def convert_extracted_to_processed(extracted_data):
    """Convert extracted_data format (from database) to processed_data format (for app)"""
    if not extracted_data:
        return None
    
    try:
        # Create a DataFrame from extracted_data
        consolidated_data = []
        for year, year_data in sorted(extracted_data.items()):
            revenue = year_data.get('revenue', {}).get('ANNUAL', 0)
            costs = year_data.get('costs', {}).get('ANNUAL', 0)
            
            # Get expenses
            admin_expenses = year_data.get('admin_expenses', {}).get('ANNUAL', 0)
            operational_expenses = year_data.get('operational_expenses', {}).get('ANNUAL', 0)
            marketing_expenses = year_data.get('marketing_expenses', {}).get('ANNUAL', 0)
            financial_expenses = year_data.get('financial_expenses', {}).get('ANNUAL', 0)
            
            # Get fixed costs directly from Excel (CUSTOS FIXOS line)
            fixed_costs_data = year_data.get('fixed_costs', {})
            if isinstance(fixed_costs_data, dict):
                fixed_costs = fixed_costs_data.get('ANNUAL', 0)
            else:
                fixed_costs = fixed_costs_data if fixed_costs_data else 0
            
            # If no direct fixed costs data, calculate as sum of expenses (fallback)
            if fixed_costs == 0:
                fixed_costs = admin_expenses + operational_expenses + marketing_expenses + financial_expenses
            
            # Calculate operational costs
            operational_costs_data = year_data.get('operational_costs', {})
            if isinstance(operational_costs_data, dict):
                operational_costs = operational_costs_data.get('ANNUAL', 0)
            else:
                operational_costs = operational_costs_data
                
            if operational_costs == 0:
                operational_costs = admin_expenses + operational_expenses
            
            # Calculate all required fields
            total_costs = costs + fixed_costs
            net_profit = revenue - total_costs
            profit_margin = (net_profit / revenue * 100) if revenue > 0 else 0
            gross_profit = revenue - costs
            gross_margin = (gross_profit / revenue * 100) if revenue > 0 else 0
            contribution_margin = revenue - costs
            
            consolidated_data.append({
                'year': int(year),
                'revenue': revenue,
                'variable_costs': costs,
                'fixed_costs': fixed_costs,
                'admin_expenses': admin_expenses,
                'operational_expenses': operational_expenses,
                'marketing_expenses': marketing_expenses,
                'financial_expenses': financial_expenses,
                'operational_costs': operational_costs,
                'total_costs': total_costs,
                'net_profit': net_profit,
                'profit': net_profit,
                'profit_margin': profit_margin,
                'gross_profit': gross_profit,
                'gross_margin': gross_margin,
                'contribution_margin': contribution_margin
            })
        
        if consolidated_data:
            consolidated_df = pd.DataFrame(consolidated_data)
            
            # Calculate growth metrics
            processor = FinancialProcessor()
            consolidated_df = processor.calculate_growth_metrics(consolidated_df)
            
            return {
                'raw_data': extracted_data,
                'consolidated': consolidated_df,
                'summary': processor.get_financial_summary(consolidated_df),
                'anomalies': []
            }
    except Exception as e:
        print(f"Error converting data: {e}")
        return None

def sync_processed_to_extracted():
    """Sync processed_data to extracted_data format for database saving"""
    if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data and 'raw_data' in st.session_state.processed_data:
        # If we have raw_data, it's already in extracted format with all monthly data
        st.session_state.extracted_data = st.session_state.processed_data['raw_data']
    elif hasattr(st.session_state, 'processed_data') and st.session_state.processed_data and 'consolidated' in st.session_state.processed_data:
        # If we don't have raw_data, but we have monthly_data, use that
        if (hasattr(st.session_state, 'monthly_data') and 
            st.session_state.monthly_data is not None and
            isinstance(st.session_state.monthly_data, pd.DataFrame) and
            not st.session_state.monthly_data.empty and
            'year' in st.session_state.monthly_data.columns):
            extracted = {}
            monthly_df = st.session_state.monthly_data
            
            # Group by year and rebuild the extracted format with monthly data
            for year in monthly_df['year'].unique():
                year_data = monthly_df[monthly_df['year'] == year]
                revenue_dict = {}
                costs_dict = {}
                
                # Add monthly data
                for _, row in year_data.iterrows():
                    month = row['month']
                    revenue_dict[month] = row.get('revenue', 0)
                    # Handle both 'costs' and 'variable_costs' columns
                    if 'variable_costs' in row:
                        costs_dict[month] = row.get('variable_costs', 0)
                    else:
                        costs_dict[month] = row.get('costs', 0)
                
                # Add annual totals
                revenue_dict['ANNUAL'] = sum(v for k, v in revenue_dict.items() if k != 'ANNUAL')
                costs_dict['ANNUAL'] = sum(v for k, v in costs_dict.items() if k != 'ANNUAL')
                
                extracted[str(year)] = {
                    'revenue': revenue_dict,
                    'costs': costs_dict,
                    'year': int(year)
                }
            
            st.session_state.extracted_data = extracted
        else:
            # Fallback: only ANNUAL data available
            extracted = {}
            df = st.session_state.processed_data.get('consolidated', pd.DataFrame())
            
            # Ensure df is a DataFrame before iterating
            if isinstance(df, pd.DataFrame) and not df.empty:
                for _, row in df.iterrows():
                    year = str(int(row['year']))
                    extracted[year] = {
                        'revenue': {'ANNUAL': row.get('revenue', 0)},
                        'costs': {'ANNUAL': row.get('variable_costs', 0)},
                        'fixed_costs': row.get('fixed_costs', 0),
                        'operational_costs': row.get('operational_costs', 0),
                        'year': int(year)
                    }
            
            st.session_state.extracted_data = extracted

# Try to load data from database FIRST
data_loaded = db.auto_load_state(st.session_state)

# Check if we have cached analyzed data
# Data loading checks removed - debugging complete

if data_loaded and hasattr(st.session_state, 'processed_data') and st.session_state.processed_data:
    pass    # Using cached analyzed data - no reconstruction needed
    # Everything is already loaded from cache by auto_load_state
elif data_loaded and hasattr(st.session_state, 'extracted_data') and st.session_state.extracted_data:
    # Only reconstruct if we don't have cached processed_data but have raw extracted_data
    # No cached analysis found, converting from raw data
    processed = convert_extracted_to_processed(st.session_state.extracted_data)
    if processed:
        st.session_state.processed_data = processed
        # Successfully converted to processed format
    
    # Also need to generate monthly data from extracted data
    try:
        # Create monthly DataFrame from extracted data with ALL required fields
        monthly_data = []
        for year, year_data in st.session_state.extracted_data.items():
            revenue_data = year_data.get('revenue', {})
            costs_data = year_data.get('costs', {})
            admin_data = year_data.get('admin_expenses', {})
            operational_data = year_data.get('operational_expenses', {})
            marketing_data = year_data.get('marketing_expenses', {})
            financial_data = year_data.get('financial_expenses', {})
            fixed_costs_data = year_data.get('fixed_costs', {})
            
            for month in ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']:
                if month in revenue_data:
                    revenue = revenue_data.get(month, 0)
                    variable_costs = costs_data.get(month, 0)
                    
                    # Get fixed costs directly from Excel data
                    fixed_costs = fixed_costs_data.get(month, 0)
                    
                    # If no direct fixed costs data, calculate as sum of expenses (fallback)
                    if fixed_costs == 0:
                        fixed_costs = (
                            admin_data.get(month, 0) + 
                            operational_data.get(month, 0) + 
                            marketing_data.get(month, 0) + 
                            financial_data.get(month, 0)
                        )
                    
                    # Calculate operational costs (admin + operational)
                    operational_costs = admin_data.get(month, 0) + operational_data.get(month, 0)
                    
                    # Calculate profit and margins
                    total_costs = variable_costs + fixed_costs
                    net_profit = revenue - total_costs
                    profit_margin = (net_profit / revenue * 100) if revenue > 0 else 0
                    contribution_margin = revenue - variable_costs
                    
                    monthly_data.append({
                        'year': int(year),
                        'month': month,
                        'revenue': revenue,
                        'variable_costs': variable_costs,
                        'fixed_costs': fixed_costs,
                        'admin_expenses': admin_data.get(month, 0),
                        'operational_expenses': operational_data.get(month, 0),
                        'marketing_expenses': marketing_data.get(month, 0),
                        'financial_expenses': financial_data.get(month, 0),
                        'total_costs': total_costs,
                        'operational_costs': operational_costs,
                        'net_profit': net_profit,
                        'profit_margin': profit_margin,
                        'contribution_margin': contribution_margin
                    })
        
        if monthly_data:
            st.session_state.monthly_data = pd.DataFrame(monthly_data)
            # Generated monthly data successfully
    except Exception as e:
        print(f"Error generating monthly data: {e}")
        import traceback
        traceback.print_exc()

# Initialize session state
if 'file_manager' not in st.session_state:
    st.session_state.file_manager = GerenciadorArquivos()
    # Sincronizar arquivos existentes
    st.session_state.file_manager.sincronizar_arquivos_existentes()
if 'ai_chat_assistant' not in st.session_state:
    st.session_state.ai_chat_assistant = None

# Only initialize empty defaults if nothing was loaded from database
if not data_loaded:
    if 'processed_data' not in st.session_state:
        st.session_state.processed_data = None
    if 'gemini_insights' not in st.session_state:
        st.session_state.gemini_insights = None
    if 'flexible_data' not in st.session_state:
        st.session_state.flexible_data = None
    if 'monthly_data' not in st.session_state:
        st.session_state.monthly_data = None
    if 'extracted_data' not in st.session_state:
        st.session_state.extracted_data = {}
    if 'financial_data' not in st.session_state:
        st.session_state.financial_data = None
    # Don't initialize selected_years and selected_months here
    # Let auto_load_state handle it to preserve saved filter states

# Debug: Show loaded data status
if data_loaded:
    if hasattr(st.session_state, 'extracted_data') and st.session_state.extracted_data:
        # Successfully loaded data from database
    if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data and 'consolidated' in st.session_state.processed_data:
        df = st.session_state.processed_data.get('consolidated')
        if isinstance(df, pd.DataFrame):
            # Processed data loaded successfully
        else:
            # Data format issue detected
    else:
        # No processed_data found in database

# Helper functions
def format_currency(value):
    """Format value as Brazilian currency"""
    if abs(value) >= 1_000_000:
        # For millions, show 2 decimal places for better precision (1.68M instead of 1.7M)
        return f"R$ {value/1_000_000:,.2f}M".replace(",", "X").replace(".", ",").replace("X", ".")
    elif abs(value) >= 1_000:
        # For thousands, show as full number with thousands separator
        return f"R$ {value:,.0f}".replace(",", "X").replace(".", ",").replace("X", ".")
    else:
        # For smaller amounts, show 2 decimal places
        return f"R$ {value:,.2f}".replace(",", "X").replace(".", ",").replace("X", ".")

def get_expense_subcategories():
    """Define detailed expense subcategories for better organization"""
    return {
        'pessoal': {
            'name': 'üë• Pessoal',
            'subcategories': {
                'salarios': {
                    'name': 'Sal√°rios e Ordenados',
                    'patterns': ['salario', 'sal√°rio', 'ordenado', 'remuneracao', 'remunera√ß√£o', 'folha de pagamento', 'holerite']
                },
                'beneficios': {
                    'name': 'Benef√≠cios',
                    'patterns': ['vale transporte', 'vale-transporte', 'vt', 'vale refeicao', 'vale refei√ß√£o', 'vale alimentacao', 'vale alimenta√ß√£o', 'va', 'vr']
                },
                'encargos': {
                    'name': 'Encargos Sociais',
                    'patterns': ['inss', 'fgts', 'encargo', 'previdencia', 'previd√™ncia', 'contribuicao social', 'contribui√ß√£o social']
                },
                'provisoes': {
                    'name': 'Provis√µes',
                    'patterns': ['ferias', 'f√©rias', '13o', '13¬∫', 'decimo terceiro', 'd√©cimo terceiro', 'provisao', 'provis√£o']
                }
            }
        },
        'ocupacao': {
            'name': 'üè¢ Ocupa√ß√£o e Utilidades',
            'subcategories': {
                'aluguel': {
                    'name': 'Aluguel e Condom√≠nio',
                    'patterns': ['aluguel', 'locacao', 'loca√ß√£o', 'condominio', 'condom√≠nio', 'iptu', 'taxa condominial']
                },
                'energia': {
                    'name': 'Energia El√©trica',
                    'patterns': ['energia', 'eletrica', 'el√©trica', 'luz', 'cemig', 'light', 'cpfl', 'coelba', 'celesc']
                },
                'agua': {
                    'name': '√Ågua e Esgoto',
                    'patterns': ['agua', '√°gua', 'esgoto', 'saneamento', 'sabesp', 'copasa', 'cedae', 'cagece']
                },
                'telecom': {
                    'name': 'Telecomunica√ß√µes',
                    'patterns': ['telefone', 'internet', 'telefonia', 'celular', 'vivo', 'claro', 'tim', 'oi', 'net']
                }
            }
        },
        'servicos': {
            'name': 'üíº Servi√ßos Profissionais',
            'subcategories': {
                'contabilidade': {
                    'name': 'Contabilidade',
                    'patterns': ['contabilidade', 'contador', 'contabil', 'cont√°bil', 'escritorio contabil', 'escrit√≥rio cont√°bil']
                },
                'juridico': {
                    'name': 'Jur√≠dico',
                    'patterns': ['advocacia', 'advogado', 'juridico', 'jur√≠dico', 'honorario', 'honor√°rio', 'judicial']
                },
                'consultoria': {
                    'name': 'Consultoria',
                    'patterns': ['consultoria', 'consultor', 'assessoria', 'treinamento', 'capacitacao', 'capacita√ß√£o']
                },
                'ti': {
                    'name': 'TI e Software',
                    'patterns': ['software', 'sistema', 'ti', 'informatica', 'inform√°tica', 'licenca', 'licen√ßa', 'assinatura', 'cloud', 'nuvem']
                }
            }
        },
        'manutencao': {
            'name': 'üîß Manuten√ß√£o e Conserva√ß√£o',
            'subcategories': {
                'limpeza': {
                    'name': 'Limpeza',
                    'patterns': ['limpeza', 'higienizacao', 'higieniza√ß√£o', 'faxina', 'jardinagem', 'conservacao', 'conserva√ß√£o']
                },
                'predial': {
                    'name': 'Manuten√ß√£o Predial',
                    'patterns': ['manutencao predial', 'manuten√ß√£o predial', 'reforma', 'pintura', 'obra', 'reparo', 'conserto']
                },
                'equipamentos': {
                    'name': 'Manuten√ß√£o de Equipamentos',
                    'patterns': ['manutencao equipamento', 'manuten√ß√£o equipamento', 'assistencia tecnica', 'assist√™ncia t√©cnica', 'reparo equipamento']
                }
            }
        },
        'material': {
            'name': 'üì¶ Material de Consumo',
            'subcategories': {
                'escritorio': {
                    'name': 'Material de Escrit√≥rio',
                    'patterns': ['material escritorio', 'material escrit√≥rio', 'papelaria', 'papel', 'caneta', 'toner', 'cartucho']
                },
                'limpeza_material': {
                    'name': 'Material de Limpeza',
                    'patterns': ['material limpeza', 'produto limpeza', 'detergente', 'desinfetante', 'papel higienico', 'papel higi√™nico']
                },
                'combustivel': {
                    'name': 'Combust√≠veis',
                    'patterns': ['combustivel', 'combust√≠vel', 'gasolina', 'alcool', '√°lcool', 'diesel', 'posto', 'abastecimento']
                }
            }
        }
    }

def classify_expense_subcategory(description):
    """Classify an expense into a subcategory based on its description"""
    description_lower = description.lower()
    subcategories = get_expense_subcategories()
    
    for main_cat, main_data in subcategories.items():
        for sub_cat, sub_data in main_data['subcategories'].items():
            for pattern in sub_data['patterns']:
                if pattern in description_lower:
                    return {
                        'main_category': main_cat,
                        'main_category_name': main_data['name'],
                        'subcategory': sub_cat,
                        'subcategory_name': sub_data['name']
                    }
    
    # Default to uncategorized
    return {
        'main_category': 'outros',
        'main_category_name': 'üìå Outros',
        'subcategory': 'nao_categorizado',
        'subcategory_name': 'N√£o Categorizado'
    }

def calculate_percentage_change(old_value, new_value):
    """Calculate percentage change between two values"""
    if old_value == 0:
        return 0
    return ((new_value - old_value) / old_value) * 100


def get_category_icon(category):
    """Get icon for each category"""
    icons = {
        'revenue': 'üí∞',
        'variable_costs': 'üì¶',
        'fixed_costs': 'üè¢',
        'admin_expenses': 'üìã',
        'operational_expenses': '‚öôÔ∏è',
        'marketing_expenses': 'üì¢',
        'financial_expenses': 'üí≥',
        'tax_expenses': 'üìä',
        'other_expenses': 'üìå',
        'other_costs': 'üìç',
        'results': 'üìà',
        'margins': 'üìä',
        'calculated_results': 'üßÆ',
        'other': 'üìÑ'
    }
    return icons.get(category, 'üìÑ')

def get_category_name(category):
    """Get friendly name for category"""
    names = {
        'revenue': 'Receitas',
        'variable_costs': 'Custos Vari√°veis',
        'fixed_costs': 'Custos Fixos',
        'admin_expenses': 'Despesas Administrativas',
        'operational_expenses': 'Despesas Operacionais',
        'marketing_expenses': 'Despesas de Marketing',
        'financial_expenses': 'Despesas Financeiras',
        'tax_expenses': 'Impostos e Taxas',
        'other_expenses': 'Outras Despesas',
        'other_costs': 'Outros Custos',
        'results': 'Resultados',
        'margins': 'Margens',
        'calculated_results': 'Resultados Calculados',
        'other': 'Outros'
    }
    return names.get(category, category.title())


def prepare_x_axis(df, view_type):
    """Prepare x-axis column and title based on view type"""
    if view_type == "Anual":
        return 'year', 'Ano'
    elif view_type == "Mensal":
        # Check if we actually have monthly data (with 'month' column)
        if 'month' in df.columns:
            if 'period' not in df.columns:
                # Create more readable period format
                month_abbr = {
                    'JAN': 'Jan', 'FEV': 'Fev', 'MAR': 'Mar', 'ABR': 'Abr',
                    'MAI': 'Mai', 'JUN': 'Jun', 'JUL': 'Jul', 'AGO': 'Ago',
                    'SET': 'Set', 'OUT': 'Out', 'NOV': 'Nov', 'DEZ': 'Dez'
                }
                df['period'] = df.apply(lambda x: f"{month_abbr.get(x['month'], x['month'])}/{str(int(x['year']))[-2:]}", axis=1)
            return 'period', 'Per√≠odo'
        else:
            # Fallback to annual view when monthly data is not available
            return 'year', 'Ano'
    elif view_type in ["Trimestral", "Trimestre Personalizado", "Semestral"]:
        return 'period', 'Per√≠odo'
    else:
        return 'year', 'Ano'

def get_monthly_layout_config():
    """Get layout configuration for monthly interactive graphs"""
    return dict(
        rangeslider=dict(visible=True, thickness=0.1),
        rangeselector=dict(
            buttons=list([
                dict(count=3, label="3M", step="month", stepmode="backward"),
                dict(count=6, label="6M", step="month", stepmode="backward"),
                dict(count=12, label="12M", step="month", stepmode="backward"),
                dict(count=24, label="24M", step="month", stepmode="backward"),
                dict(step="all", label="Tudo")
            ]),
            x=0, y=1.15
        ),
        # Set default range to show last 12 months for better readability
        range=None  # Will be set dynamically in each graph
    )

def process_detailed_monthly_data(flexible_data):
    """Process flexible data to extract detailed monthly line items for analysis"""
    if not flexible_data:
        return None
    
    detailed_data = {
        'line_items': [],
        'por_mes': {},
        'por_categoria': {},
        'por_subcategoria': {},
        'por_ano': {},
        'summary': {
            'total_items': 0,
            'total_categories': set(),
            'total_subcategories': set(),
            'years': set()
        }
    }
    
    months = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
              'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
    
    # Process each year
    for year, year_data in flexible_data.items():
        detailed_data['por_ano'][year] = []
        detailed_data['summary']['years'].add(year)
        
        # Process each line item
        for item_key, item_data in year_data['line_items'].items():
            label = item_data['label']
            category = item_data['category']
            annual_value = item_data['annual']
            monthly_values = item_data.get('monthly', {})
            
            # Skip calculated items, margins, revenue, results, and headers
            # Focus only on costs and expenses for analysis
            if category in ['calculated_results', 'margins', 'revenue', 'results', 'resultados', 'faturamento'] or item_data.get('is_subtotal', False):
                continue
            
            # Only include actual cost and expense categories
            cost_expense_categories = [
                'variable_costs', 'fixed_costs', 'admin_expenses', 
                'operational_expenses', 'marketing_expenses', 'financial_expenses',
                'tax_expenses', 'other_expenses', 'other_costs', 'other'
            ]
            if category not in cost_expense_categories:
                continue
            
            # Only include items that are explicitly marked as line items
            if not item_data.get('is_line_item', True):
                continue
            
            # Additional check: Skip if label is a known header or calculation
            label_upper = label.upper().strip()
            skip_patterns = [
                'FATURAMENTO', 'CUSTOS VARI√ÅVEIS', 'CUSTOS FIXOS', 
                'CUSTOS N√ÉO OPERACIONAIS', 'MARGEM DE CONTRIBUI√á√ÉO',
                'RESULTADO', 'PONTO EQUILIBRIO', 'PONTO EQUIL√çBRIO',
                'LUCRO', 'LUCRO L√çQUIDO', 'MARGEM DE LUCRO', 'TOTAL DESPESAS',
                'COMPOSI√á√ÉO DE SALDOS', 'APLICA√á√ïES', 'RETIRADA',
                'DESPESAS - TOTAL', 'CUSTO FIXO + VARIAVEL',
                'CUSTOS FIXOS + VARI√ÅVEIS', 'CUSTOS VARI√ÅVEIS + FIXOS',
                'CUSTOS FIXOS + VARI√ÅVEIS + N√ÉO OPERACIONAIS',
                'TOTAL CUSTOS', 'CUSTO TOTAL', 'TOTAL GERAL',
                'DESPESA TOTAL', 'TOTAL DE CUSTOS', 'TOTAL DE DESPESAS',
                'SUBTOTAL', 'SUB TOTAL', 'SUB-TOTAL'
            ]
            if any(pattern in label_upper for pattern in skip_patterns):
                continue
            
            # Skip if label contains mathematical operators (likely a calculation)
            if any(op in label for op in ['+', '=', ' - ', '(', ')']):
                continue
            
            # Skip if it's ALL CAPS (likely a header) but not a known abbreviation
            exceptions = ['IRRF', 'INSS', 'FGTS', 'IPTU', 'IPVA', 'ISS', 'PIS', 'COFINS']
            if label_upper == label.strip() and len(label.strip()) > 3 and label_upper not in exceptions:
                continue
            
            # Skip if annual value is suspiciously high (likely a total/sum)
            # Most individual expense line items should be under 500k annually
            if annual_value > 500000:
                # Only allow high-value items if they're clearly individual expenses
                allowed_high_value = ['sal√°rio', 'folha', 'aluguel', 'energia', 'comiss√£o']
                if not any(term in label.lower() for term in allowed_high_value):
                    continue
            
            detailed_data['summary']['total_categories'].add(category)
            detailed_data['summary']['total_items'] += 1
            
            # Classify into subcategory
            subcategory_info = classify_expense_subcategory(label)
            
            # Create detailed record
            record = {
                'ano': year,
                'categoria': category,
                'subcategoria_principal': subcategory_info['main_category'],
                'subcategoria_principal_nome': subcategory_info['main_category_name'],
                'subcategoria': subcategory_info['subcategory'],
                'subcategoria_nome': subcategory_info['subcategory_name'],
                'descricao': label,
                'valor_anual': annual_value,
                'valores_mensais': monthly_values,
                'item_id': item_key
            }
            
            detailed_data['line_items'].append(record)
            detailed_data['por_ano'][year].append(record)
            
            # Group by category
            if category not in detailed_data['por_categoria']:
                detailed_data['por_categoria'][category] = []
            detailed_data['por_categoria'][category].append(record)
            
            # Group by subcategory
            subcat_key = f"{subcategory_info['main_category']}_{subcategory_info['subcategory']}"
            if subcat_key not in detailed_data['por_subcategoria']:
                detailed_data['por_subcategoria'][subcat_key] = {
                    'nome': f"{subcategory_info['main_category_name']} - {subcategory_info['subcategory_name']}",
                    'items': []
                }
            detailed_data['por_subcategoria'][subcat_key]['items'].append(record)
            detailed_data['summary']['total_subcategories'].add(subcat_key)
            
            # Group by month
            for month, value in monthly_values.items():
                if month not in detailed_data['por_mes']:
                    detailed_data['por_mes'][month] = []
                
                detailed_data['por_mes'][month].append({
                    'ano': year,
                    'categoria': category,
                    'descricao': label,
                    'valor': value
                })
    
    return detailed_data

def process_hybrid_monthly_data(hybrid_data):
    """Process hybrid data (from create_hybrid_micro_data) for micro analysis"""
    if not hybrid_data or not hybrid_data.get('line_items'):
        return None
    
    detailed_data = {
        'line_items': [],
        'por_mes': {},
        'por_categoria': {},
        'por_subcategoria': {},
        'por_ano': {},
        'summary': {
            'total_items': 0,
            'total_categories': set(),
            'total_subcategories': set(),
            'years': set()
        }
    }
    
    # CRITICAL: Only copy hybrid items, NOT flexible data
    # The hybrid_data['line_items'] should contain ONLY 2 items per year (variable + fixed costs)
    print(f"DEBUG process_hybrid_monthly_data: hybrid_data has {len(hybrid_data['line_items'])} items")
    
    # Make a clean copy of ONLY the hybrid items
    hybrid_items_only = []
    for item in hybrid_data['line_items']:
        # Add 'key' field for compatibility if it doesn't exist
        if 'key' not in item:
            item['key'] = item.get('item_id', f"{item['ano']}_{item['descricao'][:20]}")
        hybrid_items_only.append(item.copy())
    
    detailed_data['line_items'] = hybrid_items_only
    detailed_data['summary']['total_items'] = len(hybrid_data['line_items'])
    
    # Group the items by year, category, etc.
    for item in hybrid_data['line_items']:
        year = item['ano']
        category = item['categoria']
        
        # Add to year grouping
        if year not in detailed_data['por_ano']:
            detailed_data['por_ano'][year] = []
        detailed_data['por_ano'][year].append(item)
        detailed_data['summary']['years'].add(year)
        
        # Add to category grouping
        if category not in detailed_data['por_categoria']:
            detailed_data['por_categoria'][category] = []
        detailed_data['por_categoria'][category].append(item)
        detailed_data['summary']['total_categories'].add(category)
        
        # Add to subcategory grouping
        subcat_key = f"{item.get('subcategoria_principal', 'other')}_{item.get('subcategoria', 'other')}"
        if subcat_key not in detailed_data['por_subcategoria']:
            detailed_data['por_subcategoria'][subcat_key] = {
                'nome': f"{item.get('subcategoria_principal_nome', 'Outros')} - {item.get('subcategoria_nome', 'Outros')}",
                'items': []
            }
        detailed_data['por_subcategoria'][subcat_key]['items'].append(item)
        detailed_data['summary']['total_subcategories'].add(subcat_key)
        
        # Add to monthly grouping
        for month, value in item.get('valores_mensais', {}).items():
            if value > 0:
                if month not in detailed_data['por_mes']:
                    detailed_data['por_mes'][month] = []
                detailed_data['por_mes'][month].append({
                    'ano': year,
                    'categoria': category,
                    'descricao': item['descricao'],
                    'valor': value
                })
    
    # Convert sets to lists for JSON serialization
    detailed_data['summary']['total_categories'] = list(detailed_data['summary']['total_categories'])
    detailed_data['summary']['total_subcategories'] = list(detailed_data['summary']['total_subcategories'])
    detailed_data['summary']['years'] = sorted(list(detailed_data['summary']['years']))
    
    return detailed_data

def get_plotly_config():
    """Get Plotly configuration for interactive graphs"""
    return {
        'displayModeBar': True,
        'displaylogo': False,
        'modeBarButtonsToAdd': ['pan2d', 'zoom2d', 'resetScale2d'],
        'scrollZoom': True
    }

def get_default_monthly_range(df, x_col, months=12):
    """Calculate default range for monthly graphs to show last N months"""
    if len(df) > months:
        return [df[x_col].iloc[-months], df[x_col].iloc[-1]]
    return None

# Check authentication
if st.session_state.user is None:
    show_login_page()
else:
    # Show user menu in sidebar
    show_user_menu()
    
    # Check if admin panel should be shown
    if 'show_admin' in st.session_state and st.session_state.show_admin:
        show_admin_panel()
        if st.button("‚Üê Voltar ao Dashboard"):
            st.session_state.show_admin = False
            st.rerun()
    else:
        # Main app content
        # Title and description
        st.title("üè¢ Marine Seguros - Financial Analytics Platform")
        st.markdown("### An√°lise Financeira Inteligente com IA | 2018-2025")

        # Sidebar for configuration
        with st.sidebar:
            st.header("‚öôÔ∏è Configura√ß√µes")
    
            # Database status
            st.markdown("### üíæ Status do Banco de Dados")
            stats = db.get_data_stats()
    
            if stats.get('financial_data', {}).get('count', 0) > 0:
                st.success(f"‚úÖ {stats['financial_data']['count']} anos de dados salvos")
        
                # Show last update times
                for data_type, info in stats.items():
                    if info.get('last_update'):
                        try:
                            last_update = datetime.fromisoformat(info['last_update'].replace('Z', '+00:00'))
                            time_diff = datetime.now() - last_update.replace(tzinfo=None)
                    
                            if time_diff.days > 0:
                                age_str = f"{time_diff.days} dias atr√°s"
                            elif time_diff.seconds > 3600:
                                age_str = f"{time_diff.seconds // 3600} horas atr√°s"
                            else:
                                age_str = f"{time_diff.seconds // 60} minutos atr√°s"
                    
                            display_name = data_type.replace('_', ' ').title()
                            st.caption(f"üìù {display_name}: {age_str}")
                        except:
                            pass
        
                # Add reload button
                if st.button("üîÑ Recarregar Dados Salvos", use_container_width=True):
                    if db.auto_load_state(st.session_state):
                        # Everything is loaded from cache by auto_load_state
                        st.success("‚úÖ Dados carregados do cache!")
                        st.rerun()
            else:
                st.warning("‚ùå Nenhum dado salvo")
    
            st.divider()
    
            # Gemini API Key input
            gemini_api_key = st.text_input(
                "Gemini API Key",
                type="password",
                value=os.getenv("GEMINI_API_KEY", ""),
                help="Enter your Google Gemini API key"
            )
    
            # Language selection
            language = st.selectbox(
                "Idioma / Language",
                ["Portugu√™s", "English"],
                index=0
            )
    
            # Analysis options
            st.subheader("Op√ß√µes de An√°lise")
            show_predictions = st.checkbox("Mostrar Previs√µes", value=True)
            show_anomalies = st.checkbox("Detectar Anomalias", value=True)
            use_flexible_extractor = st.checkbox(
                "üÜï Usar Extrator Flex√≠vel", 
                value=False,
                help="Detecta automaticamente TODAS as categorias de despesas nos arquivos Excel"
            )
            show_all_categories = st.checkbox("Mostrar Todas as Categorias", value=True)
    
            # Maintenance options
            st.subheader("Manuten√ß√£o")
            if st.button("üóëÔ∏è Limpar Cache Corrompido", type="secondary", use_container_width=True):
                # Clear the analysis cache
                db.clear_session_data()
                # Clear session state
                for key in ['processed_data', 'monthly_data', 'comparative_analysis', 'flexible_data', 'gemini_insights']:
                    if key in st.session_state:
                        del st.session_state[key]
                st.success("‚úÖ Cache limpo! Os dados ser√£o recarregados.")
                st.rerun()
            
            # Export options
            st.subheader("Exportar Dados")
            export_format = st.selectbox(
                "Formato de Exporta√ß√£o",
                ["PDF", "Excel", "PowerPoint"]
            )

        # Main content area with conditional tabs
        if use_flexible_extractor:
            tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
                "üìÅ Upload", 
                "üìä Dashboard Macro", 
                "üî¨ An√°lise Micro", 
                "ü§ñ AI Insights", 
                "üí¨ AI Chat",
                "üìà Previs√µes", 
                "‚ö° Integra√ß√£o"
            ])
        else:
            tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
                "üìÅ Upload", 
                "üìä Dashboard", 
                "ü§ñ AI Insights", 
                "üí¨ AI Chat",
                "üìà Previs√µes", 
                "‚ö° Integra√ß√£o"
            ])

        # Tab 1: File Upload
        with tab1:
            st.header("üìä Gerenciamento de Dados Financeiros")
    
            # File management bar
            col1, col2, col3 = st.columns([3, 1, 1])
    
            with col1:
                # Year filter
                anos_disponiveis = st.session_state.file_manager.obter_anos_disponiveis() if hasattr(st.session_state, 'file_manager') else []
                if anos_disponiveis:
                    anos_selecionados = st.multiselect(
                        "Filtrar por Anos:",
                        options=sorted(anos_disponiveis),
                        default=sorted(anos_disponiveis),
                        key="file_year_filter"
                    )
                else:
                    anos_selecionados = []
    
            with col2:
                if st.button("üîÑ Atualizar", help="Atualizar lista de arquivos"):
                    if hasattr(st.session_state, 'file_manager'):
                        st.session_state.file_manager.sincronizar_arquivos_existentes()
                    st.rerun()
    
            with col3:
                gerenciar_mode = st.checkbox("üìÅ Gerenciar", help="Ativar modo de gerenciamento")
    
            st.markdown("---")
    
            # Upload section - Admin only
            if st.session_state.user['role'] == 'admin':
                with st.expander("‚ûï Enviar Novos Arquivos", expanded=False):
                    uploaded_files = st.file_uploader(
                    "Selecione arquivos Excel",
                    type=['xlsx', 'xls'],
                    accept_multiple_files=True,
                    help="Formatos suportados: .xlsx, .xls | Voc√™ pode selecionar m√∫ltiplos arquivos"
                )
        
                if uploaded_files:
                    if st.button(f"üì§ Enviar {len(uploaded_files)} arquivo(s)"):
                        success_count = 0
                        error_count = 0
                
                        for uploaded_file in uploaded_files:
                            if hasattr(st.session_state, 'file_manager') and st.session_state.file_manager.enviar_arquivo(uploaded_file):
                                success_count += 1
                            else:
                                error_count += 1
                
                        if success_count > 0:
                            st.success(f"‚úÖ {success_count} arquivo(s) enviado(s) com sucesso!")
                        if error_count > 0:
                            st.error(f"‚ùå {error_count} arquivo(s) com erro")
                
                        st.rerun()
            else:
                st.info("üîí Apenas administradores podem fazer upload de arquivos.")
    
            # Display available files
            st.subheader("üìÅ Fontes de Dados Dispon√≠veis")
    
            # Clear all button when in manage mode - Admin only
            if gerenciar_mode and 'arquivos' in locals() and arquivos and st.session_state.user['role'] == 'admin':
                col1, col2 = st.columns([3, 1])
                with col2:
                    if st.button("üóëÔ∏è Limpar Todos", type="secondary", help="Remover todos os arquivos", use_container_width=True):
                        if hasattr(st.session_state, 'file_manager'):
                            for arquivo in arquivos:
                                st.session_state.file_manager.excluir_arquivo(arquivo['id'])
                        st.success("Todos os arquivos foram removidos!")
                        st.rerun()
    
            # Get files filtered by years
            if anos_selecionados and hasattr(st.session_state, 'file_manager'):
                arquivos = st.session_state.file_manager.obter_arquivos_por_anos(anos_selecionados)
            elif hasattr(st.session_state, 'file_manager'):
                arquivos = st.session_state.file_manager.obter_todos_arquivos()
            else:
                arquivos = []
    
            if arquivos:
                for arquivo in arquivos:
                    with st.container():
                        col1, col2 = st.columns([4, 1])
                
                        with col1:
                            st.markdown(f"### ‚úÖ {arquivo['nome']}")
                    
                            # File info
                            anos_str = ", ".join(map(str, sorted(arquivo['anos_incluidos'])))
                            st.markdown(f"""
                            **Anos:** {anos_str}  
                            **Enviado:** {arquivo['data_envio']} | **Tamanho:** {arquivo['tamanho']}
                            """)
                
                        with col2:
                            if gerenciar_mode and st.session_state.user['role'] == 'admin':
                                # Create unique key using file ID and a counter to handle duplicates
                                button_key = f"del_{arquivo['id']}_{id(arquivo)}"
                                if st.button("üóëÔ∏è Excluir", key=button_key):
                                    if hasattr(st.session_state, 'file_manager') and st.session_state.file_manager.excluir_arquivo(arquivo['id']):
                                        st.success("Arquivo exclu√≠do!")
                                        # Removed st.rerun() to prevent data reset
                
                        st.markdown("---")
            else:
                st.info("üì≠ Nenhum arquivo encontrado. Envie arquivos Excel para come√ßar.")
    
            # Process data button
            if arquivos:
                st.markdown("### üöÄ Processar Dados")
        
                if st.button("Analisar Dados Financeiros", type="primary", use_container_width=True):
                    # Clear old data before processing
                    keys_to_clear = ['processed_data', 'extracted_data', 'monthly_data', 'financial_data', 'gemini_insights', 'flexible_data']
                    for key in keys_to_clear:
                        if key in st.session_state:
                            del st.session_state[key]
                    # Also clear database cache
                    db.clear_session_data()
                    
                    with st.spinner("Processando arquivos..."):
                        processor = FinancialProcessor()
                
                        # Get file paths
                        file_paths = st.session_state.file_manager.obter_caminhos_arquivos() if hasattr(st.session_state, 'file_manager') else []
                
                        # Load Excel files
                        excel_data = processor.load_excel_files(file_paths)
                
                        # Always use standard extractor for macro data (Dashboard graphs)
                        consolidated_df, extracted_financial_data = processor.consolidate_all_years(excel_data)
                        
                        # Additionally use flexible extractor for detailed analysis if enabled
                        if use_flexible_extractor:
                            # Use flexible extractor for dynamic categories in detailed analysis
                            _, flexible_data = processor.consolidate_all_years_flexible(excel_data)
                            st.session_state.flexible_data = flexible_data
                        else:
                            st.session_state.flexible_data = None
                
                        # Check if data extraction was successful
                        if consolidated_df.empty:
                            st.error("‚ùå N√£o foi poss√≠vel extrair dados dos arquivos Excel.")
                            st.info("Verifique se os arquivos cont√™m as seguintes informa√ß√µes:")
                            st.markdown("""
                            - Sheets com anos (ex: 2018, 2019, 2020, etc.)
                            - Linha com 'FATURAMENTO' para receitas
                            - Linha com 'CUSTOS VARI√ÅVEIS' para custos
                            - Colunas com meses (JAN, FEV, MAR, etc.)
                            - Coluna 'ANUAL' para totais anuais
                            """)
                        else:
                            consolidated_df = processor.calculate_growth_metrics(consolidated_df)
                    
                            # Get monthly data
                            monthly_df = processor.get_monthly_data(excel_data)
                    
                            # Store in session state - always use standard extracted data for macro graphs
                            st.session_state.processed_data = {
                                'raw_data': extracted_financial_data,  # Always use standard data for consistency
                                'consolidated': consolidated_df,
                                'summary': processor.get_financial_summary(consolidated_df),
                                'anomalies': processor.detect_anomalies(consolidated_df) if show_anomalies else []
                            }
                            st.session_state.monthly_data = monthly_df
                    
                            # Sync to extracted_data format and save to database
                            sync_processed_to_extracted()
                    
                            # Save to database
                            try:
                                # Attempting to save to database
                                # Verify data exists before saving
                                db.auto_save_state(st.session_state)
                                save_success = True
                                # Save completed successfully
                            except Exception as e:
                                st.error(f"‚ö†Ô∏è Erro ao salvar no banco de dados: {str(e)}")
                                save_success = False
                                # Save failed
                                import traceback
                                traceback.print_exc()
                    
                            if use_flexible_extractor and flexible_data:
                                # Show summary of detected categories
                                all_categories = set()
                                for year_data in flexible_data.values():
                                    all_categories.update(year_data['categories'].keys())
                        
                                st.success(f"‚úÖ Dados processados com sucesso!")
                                if save_success:
                                    st.success("üíæ Dados salvos no banco de dados!")
                                st.info(f"üìä {len(consolidated_df)} anos encontrados | "
                                       f"üìÅ {len(all_categories)} categorias detectadas automaticamente")
                        
                                # Show detected categories
                                with st.expander("Categorias Detectadas"):
                                    cols = st.columns(3)
                                    for idx, category in enumerate(sorted(all_categories)):
                                        col_idx = idx % 3
                                        cols[col_idx].write(f"{get_category_icon(category)} {get_category_name(category)}")
                            else:
                                st.success(f"‚úÖ Dados processados com sucesso! {len(consolidated_df)} anos encontrados.")
                                if save_success:
                                    st.success("üíæ Dados salvos no banco de dados!")
                                st.info("üí° Os dados foram atualizados com as corre√ß√µes mais recentes para margens de lucro.")

        # Tab 2: Dashboard
        with tab2:
            st.header("Dashboard Financeiro")
    
            if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data is not None:
                data = st.session_state.processed_data
                
                # Ensure data is a dictionary
                if not isinstance(data, dict):
                    st.error(f"Error: processed_data is not a dictionary, it's a {type(data)}")
                    data = {}
                
                df = data.get('consolidated', pd.DataFrame())
                
                # Ensure df is actually a DataFrame
                if not isinstance(df, pd.DataFrame):
                    # Try to reconstruct DataFrame if it's a dict with the right structure
                    if isinstance(df, dict) and 'data' in df and 'columns' in df:
                        try:
                            df = pd.DataFrame(df['data'], columns=df['columns'])
                            st.info("üìä Dados reconstru√≠dos do cache")
                        except:
                            st.error(f"Error: Could not reconstruct DataFrame from cached data")
                            df = pd.DataFrame()
                    else:
                        st.error(f"Error: 'consolidated' data is not a DataFrame, it's a {type(df)}")
                        # Clear the corrupted data and force reprocessing
                        st.session_state.processed_data = None
                        st.info("üîÑ Por favor, clique em 'Analisar Dados' novamente para reprocessar")
                        df = pd.DataFrame()  # Create empty DataFrame to prevent errors
                elif df.empty or 'year' not in df.columns:
                    st.warning("‚ö†Ô∏è Os dados carregados parecem estar incompletos. Por favor, fa√ßa a an√°lise dos dados novamente.")
                    df = pd.DataFrame()  # Reset to empty to prevent errors
                    
                summary = data.get('summary', {})
                
                # Ensure summary is a dictionary
                if not isinstance(summary, dict):
                    st.warning(f"Summary data is not in expected format. Type: {type(summary)}")
                    summary = {}
        
        
                # Ensure monthly data is available and has all required columns
                required_monthly_cols = ['variable_costs', 'fixed_costs', 'net_profit', 'profit_margin']
                monthly_data_invalid = (
                    not hasattr(st.session_state, 'monthly_data') or 
                    st.session_state.monthly_data is None or 
                    not isinstance(st.session_state.monthly_data, pd.DataFrame) or
                    st.session_state.monthly_data.empty or
                    not all(col in st.session_state.monthly_data.columns for col in required_monthly_cols)
                )
        
                if monthly_data_invalid:
                    # Extract monthly data from the known Excel files
                    try:
                        processor = FinancialProcessor()
                
                        # Use the actual Excel files instead of the broken raw_data paths
                        excel_files = [
                            "data/arquivos_enviados/An√°lise de Resultado Financeiro 2018_2023.xlsx",
                            "data/arquivos_enviados/Resultado Financeiro - 2024.xlsx", 
                            "data/arquivos_enviados/Resultado Financeiro - 2025.xlsx"
                        ]
                
                        # Create a properly formatted excel_data dict with existing files
                        excel_data = {}
                        for file_path in excel_files:
                            if os.path.exists(file_path):
                                excel_data[file_path] = None  # The processor will handle the file reading
                
                        if excel_data:
                            monthly_data = processor.get_monthly_data(excel_data)
                    
                            if monthly_data.empty:
                                st.error("‚ùå Failed to extract monthly data from Excel files")
                            else:
                                st.success(f"‚úÖ Monthly data extracted: {len(monthly_data)} records from {len(excel_data)} files")
                                st.info(f"Years covered: {sorted(monthly_data['year'].unique()) if 'year' in monthly_data.columns else 'Unknown'}")
                    
                            st.session_state.monthly_data = monthly_data
                        else:
                            st.error("‚ùå No Excel files found for monthly data extraction")
                            st.session_state.monthly_data = pd.DataFrame()
                    
                    except Exception as e:
                        st.error(f"Error extracting monthly data: {str(e)}")
                        import traceback
                        st.code(traceback.format_exc())
                        st.session_state.monthly_data = pd.DataFrame()
        
        
                # Time Period Filters
                st.subheader("üóìÔ∏è Filtros de Per√≠odo")
        
                col_filter1, col_filter2, col_filter3, col_filter4 = st.columns(4)
        
                with col_filter1:
                    view_type = st.selectbox(
                        "Visualiza√ß√£o",
                        ["Anual", "Mensal", "Trimestral", "Trimestre Personalizado", "Semestral", "Personalizado"],
                        key="view_type"
                    )
        
                with col_filter2:
                    if view_type in ["Mensal", "Trimestral", "Trimestre Personalizado", "Semestral", "Personalizado"]:
                        if not df.empty and 'year' in df.columns:
                            available_years = sorted(df['year'].unique())
                            # Use saved selected_years if available, otherwise default to last 3 years
                            default_years = (
                                st.session_state.get('selected_years', []) 
                                if st.session_state.get('selected_years') 
                                else available_years[-3:] if len(available_years) >= 3 else available_years
                            )
                            selected_years = st.multiselect(
                                "Anos",
                                available_years,
                                default=default_years,
                                key="dashboard_selected_years"
                            )
                        else:
                            selected_years = []
                    else:
                        if not df.empty and 'year' in df.columns:
                            selected_years = sorted(df['year'].unique())
                        else:
                            selected_years = []
        
                with col_filter3:
                    if view_type == "Mensal":
                        month_names = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho",
                                      "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
                        # Use saved selected_months if available, otherwise default to all months
                        # Convert from abbreviations back to full names
                        abbrev_to_name = {
                            "JAN": "Janeiro", "FEV": "Fevereiro", "MAR": "Mar√ßo", "ABR": "Abril",
                            "MAI": "Maio", "JUN": "Junho", "JUL": "Julho", "AGO": "Agosto",
                            "SET": "Setembro", "OUT": "Outubro", "NOV": "Novembro", "DEZ": "Dezembro"
                        }
                        saved_months = st.session_state.get('selected_months', [])
                        default_months = (
                            [abbrev_to_name.get(m, m) for m in saved_months]
                            if saved_months
                            else month_names
                        )
                        selected_months = st.multiselect(
                            "Meses",
                            month_names,
                            default=default_months,
                            key="dashboard_selected_months"
                        )
                    elif view_type == "Trimestral":
                        selected_quarter = st.multiselect(
                            "Trimestres",
                            ["Q1 (Jan-Mar)", "Q2 (Abr-Jun)", "Q3 (Jul-Set)", "Q4 (Out-Dez)"],
                            default=["Q1 (Jan-Mar)", "Q2 (Abr-Jun)", "Q3 (Jul-Set)", "Q4 (Out-Dez)"],
                            key="dashboard_selected_quarters"
                        )
                    elif view_type == "Trimestre Personalizado":
                        month_names = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho",
                                      "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
                        start_month = st.selectbox(
                            "M√™s Inicial",
                            month_names,
                            key="start_month_custom"
                        )
                    elif view_type == "Semestral":
                        selected_semester = st.multiselect(
                            "Semestres",
                            ["1¬∫ Semestre (Jan-Jun)", "2¬∫ Semestre (Jul-Dez)"],
                            default=["1¬∫ Semestre (Jan-Jun)", "2¬∫ Semestre (Jul-Dez)"],
                            key="dashboard_selected_semesters"
                        )
        
                with col_filter4:
                    if view_type == "Trimestre Personalizado":
                        # Calculate end month options (3 months from start)
                        month_map = {
                            "Janeiro": 1, "Fevereiro": 2, "Mar√ßo": 3, "Abril": 4,
                            "Maio": 5, "Junho": 6, "Julho": 7, "Agosto": 8,
                            "Setembro": 9, "Outubro": 10, "Novembro": 11, "Dezembro": 12
                        }
                        month_names = list(month_map.keys())
                        start_idx = month_names.index(start_month)
                
                        # End month is exactly 2 months after start (for a 3-month period)
                        end_idx = (start_idx + 2) % 12
                        end_month_display = month_names[end_idx]
                
                        st.info(f"Trimestre: {start_month} a {end_month_display} (3 meses)")
                        end_month = end_month_display
                    elif view_type == "Personalizado":
                        date_range = st.date_input(
                            "Per√≠odo",
                            value=(pd.Timestamp(selected_years[0], 1, 1), pd.Timestamp(selected_years[-1], 12, 31)),
                            key="date_range"
                        )
                
                # Save current filter selections to session state and database
                if view_type in ["Mensal", "Trimestral", "Trimestre Personalizado", "Semestral", "Personalizado"]:
                    # Convert month names back to abbreviations for storage
                    month_mapping = {
                        "Janeiro": "JAN", "Fevereiro": "FEV", "Mar√ßo": "MAR", "Abril": "ABR",
                        "Maio": "MAI", "Junho": "JUN", "Julho": "JUL", "Agosto": "AGO",
                        "Setembro": "SET", "Outubro": "OUT", "Novembro": "NOV", "Dezembro": "DEZ"
                    }
                    
                    # Update session state
                    st.session_state.selected_years = selected_years
                    if view_type == "Mensal" and 'selected_months' in locals():
                        st.session_state.selected_months = [month_mapping.get(m, m) for m in selected_months]
                    
                    # Save to database (non-blocking)
                    try:
                        db.save_filter_state(
                            st.session_state.get('selected_years', []),
                            st.session_state.get('selected_months', [])
                        )
                    except:
                        pass  # Don't block UI if saving fails
        
                # Prepare data based on view type
                if view_type == "Anual":
                    if not df.empty and 'year' in df.columns:
                        if not df.empty and 'year' in df.columns:
                            display_df = df[df['year'].isin(selected_years)]
                        else:
                            display_df = pd.DataFrame()
                    else:
                        display_df = pd.DataFrame()
                        st.warning("‚ö†Ô∏è Dados n√£o dispon√≠veis. Por favor, fa√ßa a an√°lise dos dados primeiro.")
                elif view_type == "Mensal":
                    if not hasattr(st.session_state, 'monthly_data') or st.session_state.monthly_data is None or not isinstance(st.session_state.monthly_data, pd.DataFrame) or st.session_state.monthly_data.empty:
                        st.warning("üìã Dados mensais n√£o dispon√≠veis. Mostrando visualiza√ß√£o anual.")
                        # Debug info
                        if st.checkbox("Mostrar informa√ß√µes de debug"):
                            st.info(f"Debug: monthly_data exists: {hasattr(st.session_state, 'monthly_data')}")
                            if hasattr(st.session_state, 'monthly_data'):
                                st.info(f"Debug: monthly_data is None: {st.session_state.monthly_data is None}")
                                if st.session_state.monthly_data is not None:
                                    st.info(f"Debug: monthly_data empty: {st.session_state.monthly_data.empty}")
                                    st.info(f"Debug: monthly_data shape: {st.session_state.monthly_data.shape}")
                        if not df.empty and 'year' in df.columns:
                            display_df = df[df['year'].isin(selected_years)]
                        else:
                            display_df = pd.DataFrame()
                    else:
                        # Use monthly data
                        monthly_df = st.session_state.monthly_data
                
                        # Ensure month_num column exists
                        if 'month_num' not in monthly_df.columns and 'month' in monthly_df.columns:
                            # Create month_num from month names
                            month_to_num = {
                                'JAN': 1, 'FEV': 2, 'MAR': 3, 'ABR': 4, 'MAI': 5, 'JUN': 6,
                                'JUL': 7, 'AGO': 8, 'SET': 9, 'OUT': 10, 'NOV': 11, 'DEZ': 12
                            }
                            monthly_df['month_num'] = monthly_df['month'].map(month_to_num)
                
                        # Map month names to numbers
                        month_map = {
                            "Janeiro": 1, "Fevereiro": 2, "Mar√ßo": 3, "Abril": 4,
                            "Maio": 5, "Junho": 6, "Julho": 7, "Agosto": 8,
                            "Setembro": 9, "Outubro": 10, "Novembro": 11, "Dezembro": 12
                        }
                        selected_month_nums = [month_map[m] for m in selected_months]
                
                        display_df = monthly_df[
                            (monthly_df['year'].isin(selected_years)) &
                            (monthly_df['month_num'].isin(selected_month_nums))
                        ]
                        
                        # Add data refresh button
                        col1, col2 = st.columns([6, 1])
                        with col2:
                            if st.button("üîÑ Atualizar Dados", help="Limpar cache e reprocessar dados", key="refresh_button"):
                                # Clear all cached data
                                keys_to_clear = ['processed_data', 'extracted_data', 'monthly_data', 'financial_data', 'gemini_insights', 'flexible_data']
                                for key in keys_to_clear:
                                    if key in st.session_state:
                                        del st.session_state[key]
                                # Clear database cache
                                db.clear_session_data()
                                st.success("‚úÖ Cache limpo! Clique em 'Analisar Dados Financeiros' para reprocessar.")
                                # Removed st.rerun() to prevent data reset
                        
                        # Debug info
                        if st.checkbox("üîç Mostrar Informa√ß√µes de Debug"):
                            st.info(f"Total de meses para anos selecionados: {len(monthly_df)}")
                            st.info(f"√çndice de in√≠cio da janela: {st.session_state.get('monthly_window_start_idx', 'N√£o definido')}")
                            st.info(f"Meses exibidos: {len(display_df)}")
                            st.info(f"Anos selecionados: {selected_years}")
                            if not display_df.empty:
                                st.write("Amostra de dados mensais com margens de lucro:")
                                debug_cols = ['year', 'month', 'revenue', 'net_profit', 'profit_margin']
                                existing_cols = [col for col in debug_cols if col in display_df.columns]
                                st.dataframe(display_df[existing_cols].head(12))
                
                elif view_type == "Trimestral":
                    if not hasattr(st.session_state, 'monthly_data') or st.session_state.monthly_data is None or not isinstance(st.session_state.monthly_data, pd.DataFrame) or st.session_state.monthly_data.empty:
                        st.warning("üìã Dados mensais n√£o dispon√≠veis para visualiza√ß√£o trimestral. Mostrando visualiza√ß√£o anual.")
                        if not df.empty and 'year' in df.columns:
                            display_df = df[df['year'].isin(selected_years)]
                        else:
                            display_df = pd.DataFrame()
                    else:
                        # Aggregate monthly data by quarter
                        monthly_df = st.session_state.monthly_data
            
                        # Ensure month_num column exists
                        if 'month_num' not in monthly_df.columns and 'month' in monthly_df.columns:
                            month_to_num = {
                                'JAN': 1, 'FEV': 2, 'MAR': 3, 'ABR': 4, 'MAI': 5, 'JUN': 6,
                                'JUL': 7, 'AGO': 8, 'SET': 9, 'OUT': 10, 'NOV': 11, 'DEZ': 12
                            }
                            monthly_df['month_num'] = monthly_df['month'].map(month_to_num)
                
                        quarter_map = {
                            "Q1 (Jan-Mar)": [1, 2, 3],
                            "Q2 (Abr-Jun)": [4, 5, 6],
                            "Q3 (Jul-Set)": [7, 8, 9],
                            "Q4 (Out-Dez)": [10, 11, 12]
                        }
                        selected_months_for_quarters = []
                        for q in selected_quarter:
                            selected_months_for_quarters.extend(quarter_map[q])
                
                        filtered_monthly = monthly_df[
                            (monthly_df['year'].isin(selected_years)) &
                            (monthly_df['month_num'].isin(selected_months_for_quarters))
                        ]
                
                        # Aggregate by quarter
                        filtered_monthly['quarter'] = (filtered_monthly['month_num'] - 1) // 3 + 1
                        display_df = filtered_monthly.groupby(['year', 'quarter']).agg({
                            'revenue': 'sum',
                            'variable_costs': 'sum',
                            'fixed_costs': 'sum',
                            'operational_costs': 'sum',
                            'contribution_margin': 'sum',
                            'net_profit': 'sum',
                            'profit_margin': 'mean'  # Average the profit margins
                        }).reset_index()
                        display_df['period'] = display_df.apply(lambda x: f"{int(x['year'])}-Q{int(x['quarter'])}", axis=1)
                elif view_type == "Trimestre Personalizado":
                    if not hasattr(st.session_state, 'monthly_data') or st.session_state.monthly_data is None or not isinstance(st.session_state.monthly_data, pd.DataFrame) or st.session_state.monthly_data.empty:
                        st.warning("üìã Dados mensais n√£o dispon√≠veis para trimestre personalizado. Mostrando visualiza√ß√£o anual.")
                        if not df.empty and 'year' in df.columns:
                            display_df = df[df['year'].isin(selected_years)]
                        else:
                            display_df = pd.DataFrame()
                    else:
                        # Custom trimester logic
                        monthly_df = st.session_state.monthly_data
            
                        # Ensure month_num column exists
                        if 'month_num' not in monthly_df.columns and 'month' in monthly_df.columns:
                            month_to_num = {
                                'JAN': 1, 'FEV': 2, 'MAR': 3, 'ABR': 4, 'MAI': 5, 'JUN': 6,
                                'JUL': 7, 'AGO': 8, 'SET': 9, 'OUT': 10, 'NOV': 11, 'DEZ': 12
                            }
                            monthly_df['month_num'] = monthly_df['month'].map(month_to_num)
                
                        month_map = {
                            "Janeiro": 1, "Fevereiro": 2, "Mar√ßo": 3, "Abril": 4,
                            "Maio": 5, "Junho": 6, "Julho": 7, "Agosto": 8,
                            "Setembro": 9, "Outubro": 10, "Novembro": 11, "Dezembro": 12
                        }
                
                        start_month_num = month_map[start_month]
                        end_month_num = month_map[end_month]
                
                        # Handle year wrap-around
                        if end_month_num < start_month_num:
                            # Trimester crosses year boundary
                            selected_months_nums = list(range(start_month_num, 13)) + list(range(1, end_month_num + 1))
                        else:
                            selected_months_nums = list(range(start_month_num, end_month_num + 1))
                
                        # Filter data
                        filtered_monthly = monthly_df[
                            (monthly_df['year'].isin(selected_years)) &
                            (monthly_df['month_num'].isin(selected_months_nums))
                        ].copy()
                
                        # Group by year and custom trimester
                        def get_custom_trimester(row):
                            if row['month_num'] in selected_months_nums:
                                # If the trimester crosses year boundary
                                if end_month_num < start_month_num and row['month_num'] < start_month_num:
                                    return f"{int(row['year']-1)}/{int(row['year'])}"
                                else:
                                    return str(int(row['year']))
                            return None
                
                        filtered_monthly['custom_period'] = filtered_monthly.apply(get_custom_trimester, axis=1)
                
                        # Aggregate by custom period
                        display_df = filtered_monthly.groupby('custom_period').agg({
                            'revenue': 'sum',
                            'variable_costs': 'sum',
                            'fixed_costs': 'sum',
                            'operational_costs': 'sum',
                            'contribution_margin': 'sum',
                            'net_profit': 'sum',
                            'profit_margin': 'mean'  # Average the profit margins
                        }).reset_index()
                
                        # Add period label
                        display_df['period'] = display_df['custom_period'].apply(
                            lambda x: f"{x} ({start_month[:3]}-{end_month[:3]})"
                        )
                        display_df['year'] = display_df['custom_period']  # For compatibility
                elif view_type == "Semestral":
                    if not hasattr(st.session_state, 'monthly_data') or st.session_state.monthly_data is None or not isinstance(st.session_state.monthly_data, pd.DataFrame) or st.session_state.monthly_data.empty:
                        st.warning("üìã Dados mensais n√£o dispon√≠veis para visualiza√ß√£o semestral. Mostrando visualiza√ß√£o anual.")
                        if not df.empty and 'year' in df.columns:
                            display_df = df[df['year'].isin(selected_years)]
                        else:
                            display_df = pd.DataFrame()
                    else:
                        # Aggregate monthly data by semester
                        monthly_df = st.session_state.monthly_data
            
                        # Ensure month_num column exists
                        if 'month_num' not in monthly_df.columns and 'month' in monthly_df.columns:
                            month_to_num = {
                                'JAN': 1, 'FEV': 2, 'MAR': 3, 'ABR': 4, 'MAI': 5, 'JUN': 6,
                                'JUL': 7, 'AGO': 8, 'SET': 9, 'OUT': 10, 'NOV': 11, 'DEZ': 12
                            }
                            monthly_df['month_num'] = monthly_df['month'].map(month_to_num)
                
                        semester_map = {
                            "1¬∫ Semestre (Jan-Jun)": [1, 2, 3, 4, 5, 6],
                            "2¬∫ Semestre (Jul-Dez)": [7, 8, 9, 10, 11, 12]
                        }
                        selected_months_for_semesters = []
                        for s in selected_semester:
                            selected_months_for_semesters.extend(semester_map[s])
                
                        filtered_monthly = monthly_df[
                            (monthly_df['year'].isin(selected_years)) &
                            (monthly_df['month_num'].isin(selected_months_for_semesters))
                        ]
                
                        # Aggregate by semester
                        filtered_monthly['semester'] = (filtered_monthly['month_num'] - 1) // 6 + 1
                        display_df = filtered_monthly.groupby(['year', 'semester']).agg({
                            'revenue': 'sum',
                            'variable_costs': 'sum',
                            'fixed_costs': 'sum',
                            'operational_costs': 'sum',
                            'contribution_margin': 'sum',
                            'net_profit': 'sum',
                            'profit_margin': 'mean'  # Average the profit margins
                        }).reset_index()
                        display_df['period'] = display_df.apply(lambda x: f"{int(x['year'])}-S{int(x['semester'])}", axis=1)
                else:
                    # Default to annual view if monthly data not available
                    if not df.empty and 'year' in df.columns:
                        display_df = df[df['year'].isin(selected_years)].copy()
                    else:
                        display_df = pd.DataFrame()
            
                    # Ensure all numeric columns contain only numeric values (not dicts)
                    numeric_cols = ['revenue', 'variable_costs', 'fixed_costs', 'operational_costs', 
                                  'gross_profit', 'net_profit', 'contribution_margin']
                    for col in numeric_cols:
                        if col in display_df.columns:
                            # Convert any dict values to numbers
                            display_df[col] = display_df[col].apply(
                                lambda x: x.get('ANNUAL', 0) if isinstance(x, dict) else x
                            )
        
            
                    # Ensure profit_margin column exists for all views
                    if not display_df.empty:
                        if 'profit_margin' not in display_df.columns and 'revenue' in display_df.columns and 'net_profit' in display_df.columns:
                            display_df['profit_margin'] = display_df.apply(
                                lambda row: (row['net_profit'] / row['revenue'] * 100) if row['revenue'] > 0 else 0,
                                axis=1
                            )
                    else:
                        st.caption("‚ö†Ô∏è Nenhum dado dispon√≠vel para o per√≠odo selecionado")
        
                # Key metrics - Calculate based on filtered data
                col1, col2, col3, col4 = st.columns(4)
        
        
                # Calculate net_profit if missing
                if 'net_profit' not in display_df.columns and not display_df.empty:
                    display_df = display_df.copy()
            
                    # Ensure all numeric columns are actually numeric (not dicts)
                    for col in ['revenue', 'variable_costs', 'fixed_costs', 'operational_costs']:
                        if col in display_df.columns:
                            display_df[col] = display_df[col].apply(
                                lambda x: x.get('ANNUAL', 0) if isinstance(x, dict) else x
                            )
            
                    # Check if operational_costs exists and has values
                    if 'operational_costs' in display_df.columns:
                        operational_costs = display_df['operational_costs']
                    else:
                        operational_costs = 0
                        if st.checkbox("‚ö†Ô∏è Aviso: operational_costs n√£o encontrado", key="warn_op_costs"):
                            st.warning("Coluna 'operational_costs' n√£o encontrada. Usando 0 para custos operacionais.")
            
                    # Calculate net profit from available columns
                    if all(col in display_df.columns for col in ['revenue', 'variable_costs', 'fixed_costs']):
                        display_df['net_profit'] = display_df['revenue'] - display_df['variable_costs'] - display_df['fixed_costs'] - operational_costs
                    elif 'gross_profit' in display_df.columns and 'fixed_costs' in display_df.columns:
                        display_df['net_profit'] = display_df['gross_profit'] - display_df['fixed_costs'] - operational_costs
        
                # Calculate profit_margin only if missing
                if 'profit_margin' not in display_df.columns and 'net_profit' in display_df.columns and not display_df.empty:
                    display_df = display_df.copy()
                    display_df['profit_margin'] = (display_df['net_profit'] / display_df['revenue'] * 100).fillna(0)
        
                # Calculate metrics from filtered display_df
                total_revenue = display_df['revenue'].sum() if 'revenue' in display_df.columns and not display_df.empty else 0
        
                # Use existing profit data from the DataFrame
                if not display_df.empty:
                    # Debug: Check data types and convert dicts to numbers
                    numeric_cols = ['revenue', 'variable_costs', 'fixed_costs', 'net_profit', 'profit_margin']
                    for col in numeric_cols:
                        if col in display_df.columns:
                            # Check if any values are dicts
                            has_dicts = display_df[col].apply(lambda x: isinstance(x, dict)).any()
                            if has_dicts:
                                # Convert dict values to numbers (using ANNUAL key if available)
                                display_df[col] = display_df[col].apply(
                                    lambda x: x.get('ANNUAL', 0) if isinstance(x, dict) else x
                                )
            
                    # Use the existing net_profit and profit_margin from the data
                    total_profit = display_df['net_profit'].sum() if 'net_profit' in display_df.columns else 0
                    avg_profit = display_df['net_profit'].mean() if 'net_profit' in display_df.columns else 0
                    avg_margin = display_df['profit_margin'].mean() if 'profit_margin' in display_df.columns else 0
            
                else:
                    # Fallback to DataFrame values if we can't calculate
                    total_profit = display_df['net_profit'].sum() if 'net_profit' in display_df.columns and not display_df.empty else 0
                    avg_profit = display_df['net_profit'].mean() if 'net_profit' in display_df.columns and not display_df.empty else 0
                    avg_margin = display_df['profit_margin'].mean() if 'profit_margin' in display_df.columns and not display_df.empty else 0
        
                # For period views, show period count
                if view_type != 'Anual':
                    period_label = f"{len(display_df)} {'meses' if view_type == 'Mensal' else 'per√≠odos'}"
                else:
                    # Safely get CAGR value
                    cagr = 0
                    if isinstance(summary, dict) and 'metrics' in summary:
                        metrics = summary['metrics']
                        if isinstance(metrics, dict) and 'revenue' in metrics:
                            revenue_metrics = metrics['revenue']
                            if isinstance(revenue_metrics, dict):
                                cagr = revenue_metrics.get('cagr', 0)
                    period_label = f"{cagr:.1f}% CAGR"
        
                with col1:
                    st.metric(
                        "Receita Total",
                        format_currency(total_revenue),
                        period_label
                    )
        
                with col2:
                    # For yearly view, show total profit and clarify it's total across all years
                    if view_type == "Anual":
                        profit_label = "Lucro Total (Todos os Anos)"
                        profit_value = total_profit
                        profit_delta = f"M√©dia anual: {format_currency(avg_profit)}"
                    else:
                        profit_label = "Lucro Total"
                        profit_value = total_profit
                        profit_delta = f"{(total_profit / total_revenue * 100) if total_revenue > 0 else 0:.1f}% da receita"
            
                    st.metric(
                        profit_label,
                        format_currency(profit_value),
                        profit_delta
                    )
        
                with col3:
                    margin_range = display_df['profit_margin'].max() - display_df['profit_margin'].min() if 'profit_margin' in display_df.columns and not display_df.empty else 0
                    st.metric(
                        "Margem de Lucro M√©dia",
                        f"{avg_margin:.2f}%",
                        f"{margin_range:.2f}pp varia√ß√£o"
                    )
        
                with col4:
                    if hasattr(st.session_state, 'flexible_data') and st.session_state.flexible_data:
                        total_items = sum(
                            len(year_data['line_items']) 
                            for year_data in st.session_state.flexible_data.values()
                        ) / len(st.session_state.flexible_data)
                        st.metric(
                            "Linhas de Dados",
                            f"{int(total_items)}",
                            "M√©dia por ano"
                        )
                    else:
                        st.metric(
                            "Anos Analisados",
                            summary.get('total_years', 0),
                            summary.get('years_range', 'N/A')
                        )
        
        
                # Revenue Evolution Chart
                st.subheader("üìà Evolu√ß√£o da Receita")
                if not display_df.empty and 'revenue' in display_df.columns and display_df['revenue'].sum() > 0:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    fig_revenue = px.line(
                        display_df, 
                        x=x_col, 
                        y='revenue',
                        title=f'Receita {view_type}',
                        markers=True
                    )
            
                    # Add text annotations with smart positioning for monthly view
                    if view_type == "Mensal" and len(display_df) > 20:
                        # For crowded monthly view, show values on hover only
                        fig_revenue.update_traces(
                            hovertemplate='<b>%{x}</b><br>Receita: R$ %{y:,.0f}<extra></extra>'
                        )
                    else:
                        # For less crowded views, show selected values
                        fig_revenue.add_trace(go.Scatter(
                            x=display_df[x_col],
                            y=display_df['revenue'],
                            mode='text',
                            text=[f'R$ {v:,.0f}' if i % 3 == 0 or v == display_df['revenue'].max() or v == display_df['revenue'].min() 
                                  else '' for i, v in enumerate(display_df['revenue'])],
                            textposition='top center',
                            textfont=dict(size=10),
                            showlegend=False
                        ))
                    # For monthly view with many data points, add interactive features
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_revenue.update_layout(
                            yaxis_title="Receita (R$)",
                            xaxis_title=x_title,
                            hovermode='x unified',
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            dragmode='pan'  # Enable panning by default
                        )
                        # Configure modebar for better interaction
                        config = {
                            'displayModeBar': True,
                            'displaylogo': False,
                            'modeBarButtonsToAdd': ['pan2d', 'zoom2d', 'resetScale2d'],
                            'scrollZoom': True
                        }
                        st.plotly_chart(fig_revenue, use_container_width=True, config=config)
                    else:
                        fig_revenue.update_layout(
                            yaxis_title="Receita (R$)",
                            xaxis_title=x_title,
                            hovermode='x unified',
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else None,
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=500 if view_type == "Mensal" else 400,
                            margin=dict(t=50, b=100 if view_type == "Mensal" else 100)
                        )
                        st.plotly_chart(fig_revenue, use_container_width=True)
                else:
                    if display_df.empty:
                        st.info("üìä Nenhum dado dispon√≠vel para o per√≠odo selecionado. Verifique os filtros.")
                    else:
                        st.info("üìä Dados de receita n√£o dispon√≠veis")
        
                # Profit Margin Evolution
                if not display_df.empty and 'profit_margin' in display_df.columns:
                    st.subheader("üìä Margem de Lucro")
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    # Don't recalculate profit margin - we already have it from aggregation or extraction
                    # The profit margin is either:
                    # - Extracted from Excel for Anual/Mensal views
                    # - Averaged during aggregation for Trimestral/Semestral views
                    # Only calculate if the column is completely missing
                    if 'profit_margin' not in display_df.columns:
                        display_df['profit_margin'] = (display_df['net_profit'] / display_df['revenue'] * 100).fillna(0)
            
                    fig_margin = px.bar(
                        display_df,
                        x=x_col,
                        y='profit_margin',
                        title=f'Margem de Lucro {view_type} (%)',
                        color='profit_margin',
                        color_continuous_scale='RdYlGn'
                    )
            
                    # Always show values on bars
                    fig_margin.update_traces(
                        text=display_df['profit_margin'].apply(lambda x: f'{x:.2f}%'),
                        textposition='outside',
                        hovertemplate='<b>%{x}</b><br>Margem de Lucro: %{y:.2f}%<extra></extra>'
                    )
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_margin.update_layout(
                            yaxis_title="Margem de Lucro (%)",
                            xaxis_title=x_title,
                            coloraxis_colorbar=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                len=0.6,
                                thickness=15
                            ),
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            showlegend=False,
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_margin, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_margin.update_layout(
                            yaxis_title="Margem de Lucro (%)",
                            xaxis_title=x_title,
                            coloraxis_colorbar=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                len=0.6,
                                thickness=15
                            ),
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=450 if view_type == "Mensal" else 400,
                            margin=dict(t=80, b=100 if view_type == "Mensal" else 100),
                            showlegend=False
                        )
                        st.plotly_chart(fig_margin, use_container_width=True)
        
                # New Financial Metrics Graphs
                st.subheader("üìä An√°lise de Custos e Margens")
        
                # 1. Variable Costs vs Revenue Comparison - Full width
                if not display_df.empty and 'variable_costs' in display_df.columns and 'revenue' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    # Create figure with revenue and variable costs
                    fig_var_costs = go.Figure()
                    
                    # Add revenue line (lighter/background)
                    fig_var_costs.add_trace(go.Scatter(
                        x=display_df[x_col],
                        y=display_df['revenue'],
                        name='Receita',
                        mode='lines+markers',
                        line=dict(color='#1f77b4', width=3, dash='dot'),
                        marker=dict(size=8),
                        hovertemplate='<b>%{x}</b><br>Receita: R$ %{y:,.0f}<extra></extra>'
                    ))
                    
                    # Add variable costs line (highlighted)
                    fig_var_costs.add_trace(go.Scatter(
                        x=display_df[x_col],
                        y=display_df['variable_costs'],
                        name='Custos Vari√°veis',
                        mode='lines+markers',
                        line=dict(color='#ff7f0e', width=4),
                        marker=dict(size=10),
                        hovertemplate='<b>%{x}</b><br>Custos Vari√°veis: R$ %{y:,.0f}<extra></extra>'
                    ))
                    
                    # Calculate percentages for both cost types
                    display_df['var_cost_pct'] = (display_df['variable_costs'] / display_df['revenue'] * 100).fillna(0)
                    if 'fixed_costs' in display_df.columns:
                        display_df['fixed_cost_pct'] = (display_df['fixed_costs'] / display_df['revenue'] * 100).fillna(0)
                    
                    # Update variable costs trace to include percentage
                    fig_var_costs.data[1].update(
                        customdata=display_df['var_cost_pct'],
                        hovertemplate='<b>%{x}</b><br>Custos Vari√°veis: R$ %{y:,.0f}<br>% da Receita: %{customdata:.1f}%<extra></extra>'
                    )
                    
                    # Add fixed costs line
                    if 'fixed_costs' in display_df.columns:
                        fig_var_costs.add_trace(go.Scatter(
                            x=display_df[x_col],
                            y=display_df['fixed_costs'],
                            name='Custos Fixos',
                            mode='lines+markers',
                            line=dict(color='#d62728', width=3),
                            marker=dict(size=8, symbol='square'),
                            customdata=display_df['fixed_cost_pct'],
                            hovertemplate='<b>%{x}</b><br>Custos Fixos: R$ %{y:,.0f}<br>% da Receita: %{customdata:.1f}%<extra></extra>'
                        ))
                    
                    # Add text annotations with smart positioning
                    if view_type != "Mensal" or len(display_df) <= 20:
                        # For annual/quarterly views, show percentage on variable costs line
                        fig_var_costs.add_trace(go.Scatter(
                            x=display_df[x_col],
                            y=display_df['variable_costs'],
                            mode='text',
                            text=[f'{pct:.1f}%' for pct in display_df['var_cost_pct']],
                            textposition='top center',
                            textfont=dict(size=10, color='#ff7f0e', weight='bold'),
                            showlegend=False
                        ))
                        
                        # Add percentage annotations for fixed costs if available
                        if 'fixed_costs' in display_df.columns and 'fixed_cost_pct' in display_df.columns:
                            fig_var_costs.add_trace(go.Scatter(
                                x=display_df[x_col],
                                y=display_df['fixed_costs'],
                                mode='text',
                                text=[f'{pct:.1f}%' for pct in display_df['fixed_cost_pct']],
                                textposition='bottom center',
                                textfont=dict(size=10, color='#d62728', weight='bold'),
                                showlegend=False
                            ))
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_var_costs.update_layout(
                            title='üí∏ Custos Vari√°veis e Fixos vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            hovermode='closest',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            ),
                            dragmode='pan'
                        )
                        
                        # Add shaded area between lines to highlight the gap
                        fig_var_costs.add_trace(go.Scatter(
                            x=display_df[x_col].tolist() + display_df[x_col].tolist()[::-1],
                            y=display_df['revenue'].tolist() + display_df['variable_costs'].tolist()[::-1],
                            fill='toself',
                            fillcolor='rgba(31, 119, 180, 0.1)',
                            line=dict(color='rgba(255,255,255,0)'),
                            showlegend=False,
                            hoverinfo='skip'
                        ))
                        
                        st.plotly_chart(fig_var_costs, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_var_costs.update_layout(
                            title='üí∏ Custos Vari√°veis e Fixos vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=500 if view_type == "Mensal" else 450,
                            margin=dict(t=50, b=100 if view_type == "Mensal" else 100),
                            hovermode='closest',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            )
                        )
                        
                        # Add shaded area between lines to highlight the gap
                        fig_var_costs.add_trace(go.Scatter(
                            x=display_df[x_col].tolist() + display_df[x_col].tolist()[::-1],
                            y=display_df['revenue'].tolist() + display_df['variable_costs'].tolist()[::-1],
                            fill='toself',
                            fillcolor='rgba(31, 119, 180, 0.1)',
                            line=dict(color='rgba(255,255,255,0)'),
                            showlegend=False,
                            hoverinfo='skip'
                        ))
                        
                        st.plotly_chart(fig_var_costs, use_container_width=True)
        
                # 2. Fixed Costs - Full width
                if not display_df.empty and 'fixed_costs' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
                    
                    # Calculate percentage if not already calculated
                    if 'revenue' in display_df.columns:
                        display_df['fixed_cost_pct'] = (display_df['fixed_costs'] / display_df['revenue'] * 100).fillna(0)
            
                    # Create figure with bars for fixed costs
                    fig_fixed = go.Figure()
                    
                    # Add fixed costs bars with percentage in hover
                    fig_fixed.add_trace(go.Bar(
                        x=display_df[x_col],
                        y=display_df['fixed_costs'],
                        name='Custos Fixos',
                        marker_color='#2ca02c',
                        text=[f'R$ {v:,.0f}' if i % 2 == 0 or view_type == "Anual" else '' for i, v in enumerate(display_df['fixed_costs'])] if view_type != "Mensal" or len(display_df) <= 20 else None,
                        textposition='outside',
                        customdata=display_df['fixed_cost_pct'] if 'fixed_cost_pct' in display_df.columns else None,
                        hovertemplate='<b>%{x}</b><br>Custos Fixos: R$ %{y:,.0f}<br>% da Receita: %{customdata:.1f}%<extra></extra>'
                    ))
                    
                    # Add revenue line for comparison (same axis)
                    if 'revenue' in display_df.columns:
                        fig_fixed.add_trace(go.Scatter(
                            x=display_df[x_col],
                            y=display_df['revenue'],
                            name='Receita',
                            mode='lines+markers',
                            line=dict(color='#1f77b4', width=3),
                            marker=dict(size=8),
                            hovertemplate='<b>%{x}</b><br>Receita: R$ %{y:,.0f}<extra></extra>'
                        ))
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_fixed.update_layout(
                            title='üè¢ Custos Fixos vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            hovermode='x unified',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            ),
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_fixed, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_fixed.update_layout(
                            title='üè¢ Custos Fixos vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=450 if view_type == "Mensal" else 400,
                            margin=dict(t=50, b=100 if view_type == "Mensal" else 100),
                            hovermode='x unified',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="right",
                                x=1
                            )
                        )
                        st.plotly_chart(fig_fixed, use_container_width=True)
        
                # 3. Variable Costs - Full width (similar to Fixed Costs)
                if not display_df.empty and 'variable_costs' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
                    
                    # Calculate percentage if not already calculated
                    if 'revenue' in display_df.columns:
                        display_df['var_cost_pct'] = (display_df['variable_costs'] / display_df['revenue'] * 100).fillna(0)
            
                    # Create figure with bars for variable costs
                    fig_variable = go.Figure()
                    
                    # Add variable costs bars with percentage in hover
                    fig_variable.add_trace(go.Bar(
                        x=display_df[x_col],
                        y=display_df['variable_costs'],
                        name='Custos Vari√°veis',
                        marker_color='#ff7f0e',
                        text=[f'R$ {v:,.0f}' if i % 2 == 0 or view_type == "Anual" else '' for i, v in enumerate(display_df['variable_costs'])] if view_type != "Mensal" or len(display_df) <= 20 else None,
                        textposition='outside',
                        customdata=display_df['var_cost_pct'] if 'var_cost_pct' in display_df.columns else None,
                        hovertemplate='<b>%{x}</b><br>Custos Vari√°veis: R$ %{y:,.0f}<br>% da Receita: %{customdata:.1f}%<extra></extra>'
                    ))
                    
                    # Add revenue line for comparison (same axis)
                    if 'revenue' in display_df.columns:
                        fig_variable.add_trace(go.Scatter(
                            x=display_df[x_col],
                            y=display_df['revenue'],
                            name='Receita',
                            mode='lines+markers',
                            line=dict(color='#1f77b4', width=3),
                            marker=dict(size=8),
                            hovertemplate='<b>%{x}</b><br>Receita: R$ %{y:,.0f}<extra></extra>'
                        ))
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_variable.update_layout(
                            title='üì¶ Custos Vari√°veis vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            hovermode='x unified',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5
                            ),
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_variable, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_variable.update_layout(
                            title='üì¶ Custos Vari√°veis vs Receita',
                            yaxis_title="Valores (R$)",
                            xaxis_title=x_title,
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=450 if view_type == "Mensal" else 400,
                            margin=dict(t=80, b=100 if view_type == "Mensal" else 100),
                            hovermode='x unified',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5
                            )
                        )
                        st.plotly_chart(fig_variable, use_container_width=True)
        
                # 4. Contribution Margin - Full width
                if not display_df.empty and 'contribution_margin' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    fig_contrib = px.bar(
                        display_df,
                        x=x_col,
                        y='contribution_margin',
                        title='üìà Margem de Contribui√ß√£o',
                        color='contribution_margin',
                        color_continuous_scale='Greens'
                    )
            
                    # Always show values on top of bars
                    fig_contrib.update_traces(
                        text=[f'R$ {v:,.0f}' for v in display_df['contribution_margin']],
                        textposition='outside',
                        hovertemplate='<b>%{x}</b><br>Margem de Contribui√ß√£o: R$ %{y:,.0f}<extra></extra>'
                    )
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_contrib.update_layout(
                            yaxis_title="Margem de Contribui√ß√£o (R$)",
                            xaxis_title=x_title,
                            showlegend=False,
                            coloraxis_colorbar=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                len=0.6,
                                thickness=15
                            ),
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_contrib, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_contrib.update_layout(
                            yaxis_title="Margem de Contribui√ß√£o (R$)",
                            xaxis_title=x_title,
                            showlegend=False,
                            coloraxis_colorbar=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                len=0.6,
                                thickness=15
                            ),
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=450 if view_type == "Mensal" else 400,
                            margin=dict(t=80, b=100 if view_type == "Mensal" else 100)
                        )
                        st.plotly_chart(fig_contrib, use_container_width=True)
        
                # 4. Operational Costs - Full width  
                if not display_df.empty and 'operational_costs' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
                    
                    # Calculate percentage of operational costs relative to revenue
                    if 'revenue' in display_df.columns:
                        display_df['op_cost_pct'] = (display_df['operational_costs'] / display_df['revenue'] * 100).fillna(0)
            
                    fig_op_costs = px.area(
                        display_df,
                        x=x_col,
                        y='operational_costs',
                        title='‚öôÔ∏è Custos Operacionais',
                        color_discrete_sequence=['#d62728']
                    )
                    
                    # Update hover template to include percentage
                    if 'op_cost_pct' in display_df.columns:
                        fig_op_costs.update_traces(
                            customdata=display_df['op_cost_pct'],
                            hovertemplate='<b>%{x}</b><br>Custos Operacionais: R$ %{y:,.0f}<br>% da Receita: %{customdata:.1f}%<extra></extra>'
                        )
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_op_costs.update_layout(
                            yaxis_title="Custos Operacionais (R$)",
                            xaxis_title=x_title,
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            hovermode='x unified',
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_op_costs, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_op_costs.update_layout(
                            yaxis_title="Custos Operacionais (R$)",
                            xaxis_title=x_title,
                            xaxis=dict(
                                tickangle=-45 if view_type == "Mensal" else 0,
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else (2 if view_type == "Mensal" and len(display_df) > 24 else None),
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=450 if view_type == "Mensal" else 400,
                            margin=dict(t=50, b=100 if view_type == "Mensal" else 100),
                            hovermode='x unified'
                        )
                        st.plotly_chart(fig_op_costs, use_container_width=True)
        
                # 5. Result (Profit) - Full width
                st.subheader("üí∞ Resultado (Lucro L√≠quido)")
                if not display_df.empty and 'net_profit' in display_df.columns:
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    # Create a color scale based on positive/negative values
                    colors = ['red' if x < 0 else 'green' for x in display_df['net_profit']]
            
                    fig_result = go.Figure()
                    fig_result.add_trace(go.Bar(
                        x=display_df[x_col],
                        y=display_df['net_profit'],
                        text=display_df['net_profit'].apply(lambda x: f'R$ {x:,.0f}'),
                        textposition='outside',
                        marker_color=colors,
                        name='Resultado'
                    ))
            
                    # Add a zero line
                    fig_result.add_hline(y=0, line_dash="dash", line_color="gray")
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            tickangle=-45,
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                            
                        fig_result.update_layout(
                            title=f'Resultado {view_type} (Lucro/Preju√≠zo)',
                            yaxis_title="Resultado (R$)",
                            xaxis_title=x_title,
                            xaxis=xaxis_config,
                            height=600,
                            margin=dict(t=100, b=100),
                            showlegend=False,
                            dragmode='pan'
                        )
                        st.plotly_chart(fig_result, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_result.update_layout(
                            title=f'Resultado {view_type} (Lucro/Preju√≠zo)',
                            yaxis_title="Resultado (R$)",
                            xaxis_title=x_title,
                            height=500,
                            showlegend=False
                        )
                        st.plotly_chart(fig_result, use_container_width=True)
        
                # Cost Structure Comparison
                st.subheader("üìä Estrutura de Custos")
                if not display_df.empty and all(col in display_df.columns for col in ['variable_costs', 'fixed_costs', 'revenue']):
                    x_col, x_title = prepare_x_axis(display_df, view_type)
            
                    # Calculate total costs and profit margins
                    display_df['total_costs'] = display_df['variable_costs'] + display_df['fixed_costs']
                    display_df['profit'] = display_df['revenue'] - display_df['total_costs']
                    display_df['cost_percentage'] = (display_df['total_costs'] / display_df['revenue'] * 100).fillna(0)
            
                    # Create stacked bar chart with improved styling
                    fig_cost_structure = go.Figure()
            
                    # Calculate percentages of revenue for better visualization
                    display_df['var_cost_pct'] = (display_df['variable_costs'] / display_df['revenue'] * 100).fillna(0)
                    display_df['fixed_cost_pct'] = (display_df['fixed_costs'] / display_df['revenue'] * 100).fillna(0)
                    display_df['profit_pct'] = (display_df['profit'] / display_df['revenue'] * 100).fillna(0)
            
                    # Add variable costs bar (as percentage)
                    fig_cost_structure.add_trace(go.Bar(
                        name='Custos Vari√°veis',
                        x=display_df[x_col],
                        y=display_df['var_cost_pct'],
                        text=display_df['var_cost_pct'].apply(lambda x: f"{x:.2f}%"),
                        textposition='inside',
                        textfont=dict(color='white', size=11, weight='bold'),
                        marker=dict(
                            color='#6366F1',  # Modern purple/indigo for variable costs
                            line=dict(color='#4F46E5', width=1)
                        ),
                        hovertemplate='<b>Custos Vari√°veis</b><br>' +
                                     'Percentual: %{y:.1f}%<br>' +
                                     'Valor: R$ %{customdata[0]:,.0f}<br>' +
                                     '<b>Receita Total: R$ %{customdata[1]:,.0f}</b><br>' +
                                     '<extra></extra>',
                        customdata=list(zip(display_df['variable_costs'], display_df['revenue']))
                    ))
            
                    # Add fixed costs bar (as percentage)
                    fig_cost_structure.add_trace(go.Bar(
                        name='Custos Fixos',
                        x=display_df[x_col],
                        y=display_df['fixed_cost_pct'],
                        text=display_df['fixed_cost_pct'].apply(lambda x: f"{x:.2f}%"),
                        textposition='inside',
                        textfont=dict(color='white', size=11, weight='bold'),
                        marker=dict(
                            color='#F59E0B',  # Professional amber for fixed costs
                            line=dict(color='#D97706', width=1)
                        ),
                        hovertemplate='<b>Custos Fixos</b><br>' +
                                     'Percentual: %{y:.1f}%<br>' +
                                     'Valor: R$ %{customdata[0]:,.0f}<br>' +
                                     '<b>Receita Total: R$ %{customdata[1]:,.0f}</b><br>' +
                                     '<extra></extra>',
                        customdata=list(zip(display_df['fixed_costs'], display_df['revenue']))
                    ))
            
                    # Add profit margin bar
                    fig_cost_structure.add_trace(go.Bar(
                        name='Margem de Lucro',
                        x=display_df[x_col],
                        y=display_df['profit_pct'],
                        text=display_df['profit_pct'].apply(lambda x: f"{x:.2f}%"),
                        textposition='inside',
                        textfont=dict(color='white', size=11, weight='bold'),
                        marker=dict(
                            color='#10B981',  # Green for profit
                            line=dict(color='#047857', width=1)
                        ),
                        hovertemplate='<b>Margem de Lucro</b><br>' +
                                     'Percentual: %{y:.1f}%<br>' +
                                     'Valor: R$ %{customdata[0]:,.0f}<br>' +
                                     '<b>Receita Total: R$ %{customdata[1]:,.0f}</b><br>' +
                                     '<extra></extra>',
                        customdata=list(zip(display_df['profit'], display_df['revenue']))
                    ))
            
                    # Add 100% reference line
                    fig_cost_structure.add_hline(
                        y=100, 
                        line_dash="dot", 
                        line_color="#6B7280",
                        annotation_text="100% da Receita",
                        annotation_position="top right",
                        annotation_font=dict(size=12, color="#6B7280")
                    )
            
                    # Clean x-axis labels with just periods (revenue moved to hover)
            
            
                    # Apply interactive features for monthly view
                    if view_type == "Mensal":
                        xaxis_config = dict(
                            title=dict(
                                text=x_title,
                                font=dict(size=16, color='#1F2937', weight='bold')
                            ),
                            tickfont=dict(size=12, color='#374151'),
                            showgrid=False,
                            tickangle=-90,  # Vertical labels to prevent overlap
                            tickmode='linear',
                            **get_monthly_layout_config()
                        )
                        
                        # Set default range to show last 12 months
                        default_range = get_default_monthly_range(display_df, x_col)
                        if default_range:
                            xaxis_config['range'] = default_range
                        fig_cost_structure.update_layout(
                            title={
                                'text': 'üí∞ Estrutura de Custos vs Receita (% da Receita)',
                                'font': {'size': 24, 'color': '#1F2937'}
                            },
                            barmode='stack',
                            yaxis=dict(
                                title=dict(
                                    text="Percentual da Receita (%)",
                                    font=dict(size=16, color='#1F2937', weight='bold')
                                ),
                                tickformat='.1f',
                                ticksuffix='%',
                                tickfont=dict(size=12, color='#374151'),
                                showgrid=True,
                                gridcolor='rgba(0,0,0,0.1)',
                                range=[0, 100]
                            ),
                            xaxis=xaxis_config,
                            height=700,  # Increased height for monthly view
                            hovermode='x unified',
                            plot_bgcolor='rgba(248,249,250,0.8)',
                            paper_bgcolor='white',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                bgcolor="rgba(255,255,255,0.9)",
                                bordercolor="rgba(0,0,0,0.1)",
                                borderwidth=1,
                                font=dict(size=14, color='#374151', weight='bold')
                            ),
                            margin=dict(t=120, b=100),
                            dragmode='pan'
                        )
                        
                        # Add shapes for visual appeal
                        fig_cost_structure.update_xaxes(showline=True, linewidth=2, linecolor='#E5E7EB')
                        fig_cost_structure.update_yaxes(showline=True, linewidth=2, linecolor='#E5E7EB')
                        
                        st.plotly_chart(fig_cost_structure, use_container_width=True, config=get_plotly_config())
                    else:
                        fig_cost_structure.update_layout(
                            title={
                                'text': 'üí∞ Estrutura de Custos vs Receita (% da Receita)',
                                'font': {'size': 24, 'color': '#1F2937'}
                            },
                            barmode='stack',
                            yaxis=dict(
                                title=dict(
                                    text="Percentual da Receita (%)",
                                    font=dict(size=16, color='#1F2937', weight='bold')
                                ),
                                tickformat='.1f',
                                ticksuffix='%',
                                tickfont=dict(size=12, color='#374151'),
                                showgrid=True,
                                gridcolor='rgba(0,0,0,0.1)',
                                range=[0, 100]
                            ),
                            xaxis=dict(
                                title=dict(
                                    text=x_title,
                                    font=dict(size=16, color='#1F2937', weight='bold')
                                ),
                                tickfont=dict(size=12, color='#374151'),
                                showgrid=False,
                                tickangle=-90,  # Vertical labels to prevent overlap
                                tickmode='linear',
                                dtick=1 if view_type == "Anual" else None,
                                type='category' if view_type == "Anual" else None,
                                categoryorder='category ascending' if view_type == "Anual" else None
                            ),
                            height=600,  # Standard height for all views
                            hovermode='x unified',
                            plot_bgcolor='rgba(248,249,250,0.8)',
                            paper_bgcolor='white',
                            legend=dict(
                                orientation="h",
                                yanchor="bottom",
                                y=1.02,
                                xanchor="center",
                                x=0.5,
                                bgcolor="rgba(255,255,255,0.9)",
                                bordercolor="rgba(0,0,0,0.1)",
                                borderwidth=1,
                                font=dict(size=14, color='#374151', weight='bold')
                            ),
                            margin=dict(t=120, b=100)
                        )
                        
                        # Add shapes for visual appeal
                        fig_cost_structure.update_xaxes(showline=True, linewidth=2, linecolor='#E5E7EB')
                        fig_cost_structure.update_yaxes(showline=True, linewidth=2, linecolor='#E5E7EB')
                        
                        st.plotly_chart(fig_cost_structure, use_container_width=True)
            
            
        
                # Anomalies
                if show_anomalies and data.get('anomalies'):
                    st.subheader("‚ö†Ô∏è Anomalias Detectadas")
                    anomalies = data['anomalies']
                    
                    # Check if anomalies is a list of dicts
                    if isinstance(anomalies, list) and len(anomalies) > 0:
                        # Validate each anomaly entry
                        valid_anomalies = []
                        for a in anomalies:
                            if isinstance(a, dict) and all(k in a for k in ['year', 'metric', 'value', 'type']):
                                valid_anomalies.append(a)
                        
                        if valid_anomalies:
                            for anomaly in valid_anomalies:
                                try:
                                    st.warning(
                                        f"**{anomaly['year']}**: {anomaly['metric']} - "
                                        f"Valor: {anomaly['value']:.2f}% ({anomaly['type']})"
                                    )
                                except (KeyError, TypeError, ValueError) as e:
                                    st.error(f"Error displaying anomaly: {str(e)}")
                        else:
                            st.info("Nenhuma anomalia v√°lida encontrada.")
                    elif not isinstance(anomalies, list):
                        # Debug: show what we got instead
                        st.error(f"Anomalies data is not a list. Type: {type(anomalies)}")
                        if isinstance(anomalies, str):
                            st.error(f"String content: {anomalies[:100]}...")
        
                # Growth Analysis (only for annual view) - Moved to be last
                if view_type == "Anual":
                    st.subheader("üìä An√°lise de Crescimento")
                    growth_cols = [col for col in display_df.columns if '_growth' in col]
                    if growth_cols:
                        fig_growth = go.Figure()
                        for col in growth_cols:
                            metric_name = col.replace('_growth', '').title()
                            fig_growth.add_trace(go.Scatter(
                                x=display_df['year'],
                                y=display_df[col],
                                mode='lines+markers',
                                name=metric_name,
                                line=dict(width=3)
                            ))
                        fig_growth.update_layout(
                            title="Taxa de Crescimento Anual (%)",
                            xaxis_title="Ano",
                            yaxis_title="Crescimento (%)",
                            hovermode='x unified'
                        )
                        st.plotly_chart(fig_growth, use_container_width=True, key="growth_chart_standard")
        
                # Data table
                with st.expander("üìã Ver Dados Detalhados"):
                    st.dataframe(display_df, use_container_width=True)
    
            else:
                st.info("üëÜ Please upload files in the 'Upload' tab first.")

        # Tab 3: Detailed Breakdown (only for flexible mode)
        if use_flexible_extractor:
            with tab3:
                # Clear header with purpose statement
                st.header("üî¨ An√°lise Micro - Custos e Despesas Detalhados")
                st.markdown("""
                <div style='background-color: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 20px;'>
                    <p style='margin: 0; color: #0c5690;'>
                        üîé <strong>Investigue por que alguns anos foram melhores que outros</strong> - Analise linha por linha todos os custos e despesas para identificar onde houve aumentos ou redu√ß√µes que impactaram os resultados.
                    </p>
                </div>
                """, unsafe_allow_html=True)
        
                # Check if data is loaded - also check for hybrid_micro_data and detailed_monthly_data
                if (hasattr(st.session_state, 'processed_data') and st.session_state.processed_data is not None) or \
                   (hasattr(st.session_state, 'hybrid_micro_data') and st.session_state.hybrid_micro_data is not None) or \
                   (hasattr(st.session_state, 'detailed_monthly_data') and st.session_state.detailed_monthly_data is not None):
                    # Use hybrid approach: combine accurate macro totals with detailed line items
                    from core.process_manager import create_hybrid_micro_data
                    
                    flexible_data = getattr(st.session_state, 'flexible_data', None)
                    
                    # Create hybrid data that ensures micro totals match macro totals
                    # Only recreate if data doesn't exist
                    if 'hybrid_micro_data' not in st.session_state:
                        print("DEBUG: Creating hybrid micro data...")
                        st.session_state.hybrid_micro_data = create_hybrid_micro_data(
                            st.session_state.processed_data, 
                            None  # Keep totals accurate first
                        )
                        print(f"DEBUG: Created hybrid_micro_data with {len(st.session_state.hybrid_micro_data.get('line_items', []))} items")
                    
                    # Process the hybrid data for micro analysis
                    # Only recreate if data doesn't exist
                    if 'detailed_monthly_data' not in st.session_state:
                        print("DEBUG: Processing hybrid data for micro analysis...")
                        
                        # Create smart hybrid: use flexible data for all available years, but constrain to macro totals
                        if flexible_data:
                            macro_df = st.session_state.processed_data.get('consolidated', pd.DataFrame())
                            all_detailed_items = []
                            
                            # Process all years that have both macro and flexible data
                            for year in flexible_data.keys():
                                if not macro_df.empty:
                                    year_row = macro_df[macro_df['year'] == year]
                                    if not year_row.empty:
                                        macro_variable = year_row.iloc[0].get('variable_costs', 0)
                                        macro_fixed = year_row.iloc[0].get('fixed_costs', 0)
                                    
                                        # Use flexible data for this year but scale to macro totals
                                        flexible_year = flexible_data[year]
                                        
                                        # Get flexible totals to calculate scale factors
                                        flex_variable_total = sum(item['annual'] for item in flexible_year['line_items'].values() 
                                                                if item.get('category') == 'variable_costs')
                                        flex_fixed_total = sum(item['annual'] for item in flexible_year['line_items'].values() 
                                                             if item.get('category') in ['fixed_costs', 'admin_expenses', 'operational_expenses', 'marketing_expenses', 'financial_expenses', 'tax_expenses', 'other'])
                                        
                                        # Calculate scale factors based on flexible vs macro totals
                                        
                                        # Calculate scale factors with fallback logic
                                        if flex_variable_total > 0:
                                            variable_scale = macro_variable / flex_variable_total
                                        else:
                                            # No variable costs found in flexible data - use macro value directly
                                            variable_scale = 1.0
                                            pass  # No variable costs found - use macro value directly
                                        
                                        if flex_fixed_total > 0:
                                            fixed_scale = macro_fixed / flex_fixed_total
                                        else:
                                            # No fixed costs found - shouldn't happen but handle gracefully
                                            fixed_scale = 1.0
                                            pass  # No fixed costs found - shouldn't happen but handle gracefully
                                        
                                        # Create scaled detailed items for this year
                                        for item_key, item_data in flexible_year['line_items'].items():
                                            category = item_data.get('category', 'other')
                                            original_value = item_data.get('annual', 0)
                                            
                                            if category == 'variable_costs':
                                                scaled_value = original_value * variable_scale
                                                final_category = 'variable_costs'
                                            elif category in ['fixed_costs', 'admin_expenses', 'operational_expenses', 'marketing_expenses', 'financial_expenses', 'tax_expenses', 'other']:
                                                scaled_value = original_value * fixed_scale  
                                                final_category = 'fixed_costs'
                                            else:
                                                continue  # Skip revenue, results, etc.
                                            
                                            if scaled_value > 0:  # Only include items with value
                                                from utils.expense_categorizer import classify_expense_subcategory
                                                subcat_info = classify_expense_subcategory(item_data['label'])
                                                
                                                all_detailed_items.append({
                                                    'ano': year,
                                                    'descricao': item_data['label'],
                                                    'categoria': final_category,
                                                    'subcategoria_principal': subcat_info['main_category'],
                                                    'subcategoria_principal_nome': subcat_info['main_category_name'],
                                                    'subcategoria': subcat_info['subcategory'],
                                                    'subcategoria_nome': subcat_info['subcategory_name'],
                                                    'valor_anual': scaled_value,
                                                    'valores_mensais': {month: scaled_value/12 for month in ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']},
                                                    'key': f"{item_key}_{year}",
                                                    'item_id': f"{item_key}_{year}"
                                                })
                                        
                                        # If no variable costs were found in flexible data, create a single variable cost item
                                        if flex_variable_total == 0 and macro_variable > 0:
                                            from utils.expense_categorizer import classify_expense_subcategory
                                            subcat_info = classify_expense_subcategory("Custos Vari√°veis")
                                            
                                            all_detailed_items.append({
                                                'ano': year,
                                                'descricao': 'Custos Vari√°veis',
                                                'categoria': 'variable_costs',
                                                'subcategoria_principal': subcat_info['main_category'],
                                                'subcategoria_principal_nome': subcat_info['main_category_name'],
                                                'subcategoria': subcat_info['subcategory'],
                                                'subcategoria_nome': subcat_info['subcategory_name'],
                                                'valor_anual': macro_variable,
                                                'valores_mensais': {month: macro_variable/12 for month in ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']},
                                                'key': f'custos_variaveis_macro_{year}',
                                                'item_id': f'custos_variaveis_macro_{year}'
                                            })
                                            pass  # Added macro variable costs item
                            
                            # Create comprehensive detailed_data with all years
                            por_ano = {}
                            all_years = []
                            for item in all_detailed_items:
                                year = item['ano']
                                if year not in por_ano:
                                    por_ano[year] = []
                                    all_years.append(year)
                                por_ano[year].append(item)
                            
                            st.session_state.detailed_monthly_data = {
                                'line_items': all_detailed_items,
                                'por_mes': {},
                                'por_categoria': {},
                                'por_subcategoria': {},
                                'por_ano': por_ano,
                                'summary': {
                                    'total_items': len(all_detailed_items),
                                    'total_categories': ['variable_costs', 'fixed_costs'],
                                    'total_subcategories': [],
                                    'years': sorted(all_years)
                                }
                            }
                            
                            # Created detailed micro data successfully
                        else:
                            # Fallback to hybrid data
                            st.session_state.detailed_monthly_data = process_hybrid_monthly_data(st.session_state.hybrid_micro_data)
                        
                        # Detailed monthly data ready for display
                    
                    detailed_data = st.session_state.get('detailed_monthly_data', None)
                    
                    if detailed_data and detailed_data.get('line_items'):
                        # Get current year for default filter
                        # Ensure years are strings for consistency
                        # Use detailed_data instead of hybrid_micro_data which might be None
                        if 'summary' in detailed_data and 'years' in detailed_data['summary']:
                            years = sorted([str(y) for y in detailed_data['summary']['years']])
                        elif hasattr(st.session_state, 'hybrid_micro_data') and st.session_state.hybrid_micro_data and 'summary' in st.session_state.hybrid_micro_data:
                            years = sorted([str(y) for y in st.session_state.hybrid_micro_data['summary']['years']])
                        else:
                            # Fallback: extract years from line items
                            years = sorted(list(set(str(item.get('ano', 2025)) for item in detailed_data['line_items'])))
                        
                        current_year = years[-1] if years else None
                        
                        # Initialize session state for filters if not exists
                        if 'details_year_filter' not in st.session_state:
                            st.session_state.details_year_filter = [current_year] if current_year else []
                        if 'details_month_filter' not in st.session_state:
                            st.session_state.details_month_filter = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                                                    'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
                        if 'details_search_term' not in st.session_state:
                            st.session_state.details_search_term = ""
                        
                        # Calculate all_items early for use in filters
                        all_items = [item for item in detailed_data['line_items'] if item['categoria'] != 'revenue']
                        
                        # FILTERS SECTION - Using reusable component
                        st.markdown("### üîç Filtros")
                        
                        # Extract numeric years for the filter function
                        numeric_years = []
                        for y in years:
                            try:
                                numeric_years.append(int(y))
                            except:
                                pass
                        
                        # Use the reusable filter component
                        filter_results = create_period_filters('details', sorted(numeric_years))
                        selected_years = filter_results['selected_years']
                        selected_months = filter_results['selected_months']
                        
                        # Additional filters specific to micro analysis
                        filter_col1, filter_col2, filter_col3 = st.columns([2, 2, 3])
                        
                        with filter_col1:
                            # Category filter - exclude revenue
                            all_categories = [cat for cat in detailed_data['summary']['total_categories'] if cat != 'revenue']
                            selected_categories = st.multiselect(
                                "üìÇ Categorias",
                                options=all_categories,
                                format_func=lambda x: f"{get_category_icon(x)} {get_category_name(x)}",
                                default=all_categories
                            )
                        
                        with filter_col2:
                            # Enhanced search with suggestions
                            search_term = st.text_input(
                                "üîç Buscar",
                                placeholder="Digite para buscar (ex: vale, sal√°rio, Jo√£o)",
                                value=st.session_state.details_search_term,
                                key="search_details"
                            )
                            st.session_state.details_search_term = search_term
                            
                            # Quick search buttons
                            quick_cols = st.columns(4)
                            quick_searches = [
                                ("üë§ Pessoal", "sal√°rio"),
                                ("üöå Vale", "vale"),
                                ("üçΩÔ∏è Alimenta√ß√£o", "alimenta√ß√£o"),
                                ("üè¢ Aluguel", "aluguel")
                            ]
                            for idx, (label, term) in enumerate(quick_searches):
                                with quick_cols[idx]:
                                    if st.button(label, key=f"quick_{idx}"):
                                        st.session_state.details_search_term = term
                                        # Removed st.rerun() to prevent data reset
                        
                        # Advanced filters (hidden by default)
                        with st.expander("Filtros Avan√ßados", expanded=False):
                            adv_col1, adv_col2, adv_col3 = st.columns(3)
                            
                            with adv_col1:
                                # Subcategory filter
                                subcategories_data = get_expense_subcategories()
                                main_categories = list(subcategories_data.keys()) + ['outros']
                                selected_main_categories = st.multiselect(
                                    "Categorias Principais",
                                    options=main_categories,
                                    format_func=lambda x: subcategories_data.get(x, {}).get('name', 'üìå Outros') if x != 'outros' else 'üìå Outros',
                                    default=main_categories
                                )
                            
                            with adv_col2:
                                # Value range moved here from adv_col3
                                all_values = [item['valor_anual'] for item in all_items]
                                min_val = min(all_values) if all_values else 0
                                max_val = max(all_values) if all_values else 1000000
                                
                                value_range = st.slider(
                                    "Faixa de Valores (R$)",
                                    min_value=min_val,
                                    max_value=max_val,
                                    value=(min_val, max_val),
                                    format="R$ %d"
                                )
                            
                            with adv_col3:
                                # Additional filter options
                                st.info("üí° Use os filtros acima para refinar sua an√°lise")
                        
                        st.markdown("---")
                        
                        # Build available subcategories for filtering
                        subcategories_data = get_expense_subcategories()
                        available_subcategories = []
                        for main_cat in selected_main_categories:
                            if main_cat in subcategories_data:
                                for sub_cat in subcategories_data[main_cat]['subcategories'].keys():
                                    available_subcategories.append(f"{main_cat}_{sub_cat}")
                            elif main_cat == 'outros':
                                available_subcategories.append('outros_nao_categorizado')
                        
                        # Apply all filters to get filtered items
                        filtered_items = []
                        for item in detailed_data['line_items']:
                            # Exclude revenue items completely
                            if item['categoria'] == 'revenue':
                                continue
                                
                            # Year filter - convert to string for comparison
                            if str(item['ano']) not in [str(y) for y in selected_years]:
                                continue
                            
                            # Category filter
                            if item['categoria'] not in selected_categories:
                                continue
                            
                            # Subcategory filter (only if advanced filters expanded)
                            if 'selected_main_categories' in locals():
                                item_subcat_key = f"{item['subcategoria_principal']}_{item['subcategoria']}"
                                if item_subcat_key not in available_subcategories:
                                    continue
                            
                            # Month filter - use selected_months from the reusable filter
                            if selected_months:
                                # Check if item has any value in selected months
                                has_value_in_month = any(
                                    item['valores_mensais'].get(month, 0) > 0 
                                    for month in selected_months
                                )
                                if not has_value_in_month:
                                    continue
                            
                            # Value filter (only if advanced filters expanded)
                            if 'value_range' in locals():
                                min_value, max_value = value_range
                                if not (min_value <= item['valor_anual'] <= max_value):
                                    continue
                            
                            # Search filter
                            if search_term:
                                search_words = search_term.lower().split()
                                item_desc_lower = item['descricao'].lower()
                                if not any(word in item_desc_lower for word in search_words):
                                    continue
                            
                            filtered_items.append(item)
                        
                        # Analysis Mode Selector
                        st.markdown("### üéØ O que voc√™ quer analisar?")
                        
                        analysis_mode = st.radio(
                            "Escolha uma an√°lise focada:",
                            ["üèÜ Maiores Gastos", "üìà Crescimento R√°pido", "üîÑ Custos Recorrentes", "üí° Oportunidades"],
                            horizontal=True,
                            key="micro_analysis_mode"
                        )
                        
                        # Quick Summary Cards
                        st.markdown("### üìä Resumo R√°pido")
                        
                        # First row - cost breakdown
                        cost_cols = st.columns(4)
                        
                        # Calculate totals by cost type - simple approach: fixed + variable = total costs
                        variable_costs_total = sum(item['valor_anual'] for item in filtered_items if item['categoria'] == 'variable_costs')
                        fixed_costs_total = sum(item['valor_anual'] for item in filtered_items if item['categoria'] == 'fixed_costs')
                        
                        # Other minor categories (should be small if classification is working)
                        other_costs_total = sum(item['valor_anual'] for item in filtered_items if item['categoria'] not in ['variable_costs', 'fixed_costs', 'revenue', 'results', 'margins'])
                        
                        # Total operational costs = fixed + variable (Excel approach)
                        total_operational_costs = fixed_costs_total + variable_costs_total
                        total_annual = variable_costs_total + fixed_costs_total + other_costs_total
                        
                        with cost_cols[0]:
                            st.metric(
                                "üí∞ Total Geral",
                                format_currency(total_annual),
                                f"{len(filtered_items)} itens"
                            )
                            
                        with cost_cols[1]:
                            st.metric(
                                "üì¶ Custos Vari√°veis",
                                format_currency(variable_costs_total),
                                f"{(variable_costs_total/total_annual*100):.1f}%" if total_annual > 0 else "0%"
                            )
                            
                        with cost_cols[2]:
                            st.metric(
                                "üè¢ Custos Fixos",
                                format_currency(fixed_costs_total),
                                f"{(fixed_costs_total/total_annual*100):.1f}%" if total_annual > 0 else "0%"
                            )
                            
                        with cost_cols[3]:
                            st.metric(
                                "üìã Outros Custos/Despesas",
                                format_currency(other_costs_total),
                                f"{(other_costs_total/total_annual*100):.1f}%" if total_annual > 0 else "0%"
                            )
                        
                        # Second row - other metrics  
                        st.markdown("")  # Add spacing
                        
                        # Debug info for operational costs comparison
                        st.info(f"üí° **Total Operacional (Custos Fixos + Despesas):** {format_currency(total_operational_costs)} - Este valor deve coincidir com os custos operacionais do Excel")
                        
                        # Clear debug information
                        st.write(f"üîç **Debug Info:**")
                        st.write(f"   - Anos selecionados: {selected_years}")
                        st.write(f"   - Itens filtrados: {len(filtered_items)}")
                        st.write(f"   - Itens de receita exclu√≠dos: {len([item for item in all_items if item['categoria'] == 'revenue'])}")
                        st.write(f"   - **Total items in detailed_data**: {len(detailed_data['line_items'])}")
                        st.write(f"   - **Data source**: {'hybrid_micro_data' if hasattr(st.session_state, 'hybrid_micro_data') else 'flexible_data'}")
                        
                        # Show actual breakdown of all items
                        if len(detailed_data['line_items']) > 2:
                            st.warning(f"‚ö†Ô∏è **PROBLEMA**: detailed_data tem {len(detailed_data['line_items'])} itens, mas deveria ter apenas 2 (variable + fixed costs)")
                            st.write("üîç **Primeiros 10 itens em detailed_data:**")
                            for i, item in enumerate(detailed_data['line_items'][:10]):
                                st.write(f"   {i+1}. [{item['categoria']}] {item['descricao']} = R$ {item['valor_anual']:,.2f} (Ano: {item['ano']})")
                        else:
                            st.success(f"‚úÖ **CORRETO**: detailed_data tem apenas {len(detailed_data['line_items'])} itens (h√≠brido correto)")
                        
                        # Show EXACT 2025 values for verification
                        items_2025_only = [item for item in detailed_data['line_items'] if str(item['ano']) == '2025']
                        if items_2025_only:
                            st.write("üéØ **VALORES EXATOS PARA 2025:**")
                            for item in items_2025_only:
                                exact_value = f"R$ {item['valor_anual']:,.2f}"
                                st.write(f"   - **{item['categoria']}**: {exact_value}")
                                if item['categoria'] == 'fixed_costs':
                                    target_diff = abs(item['valor_anual'] - 1682625.88)
                                    if target_diff < 1:
                                        st.success(f"     ‚úÖ PERFEITO! Diferen√ßa: R$ {target_diff:.2f}")
                                    else:
                                        st.error(f"     ‚ùå Diferen√ßa do target (1.682.625,88): R$ {target_diff:,.2f}")
                        else:
                            st.error("‚ùå **PROBLEMA**: N√£o encontrou itens para 2025!")
                        
                        # Show breakdown by year if multiple years selected
                        if len(selected_years) > 1:
                            st.write("üìä **Breakdown por ano:**")
                            for year in sorted(selected_years):
                                year_items = [item for item in filtered_items if str(item['ano']) == str(year)]
                                year_total = sum(item['valor_anual'] for item in year_items)
                                st.write(f"   - {year}: {format_currency(year_total)} ({len(year_items)} itens)")
                        else:
                            single_year = selected_years[0] if selected_years else 'Nenhum'
                            st.write(f"   - Ano √∫nico selecionado: {single_year}")
                            if single_year == 2025:
                                st.success("‚úÖ **Analisando apenas 2025 - correto!**")
                        
                        # Validation: Check if micro total matches macro total
                        if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data:
                            macro_df = st.session_state.processed_data.get('consolidated', pd.DataFrame())
                            if not macro_df.empty and len(selected_years) == 1:
                                selected_year_int = int(selected_years[0])
                                if selected_year_int in macro_df['year'].values:
                                    row_year = macro_df[macro_df['year'] == selected_year_int].iloc[0]
                                    macro_fixed = row_year.get('fixed_costs', 0)
                                    macro_variable = row_year.get('variable_costs', 0) 
                                    macro_total = macro_fixed + macro_variable
                                    
                                    st.success(f"‚úÖ **Valida√ß√£o H√≠brida:** Macro total = {format_currency(macro_total)} | Micro total = {format_currency(total_operational_costs)}")
                                    
                                    # Compare with Excel target
                                    excel_target = 1683000  # R$ 1.683M from Excel
                                    st.info(f"üéØ **Excel Target:** {format_currency(excel_target)}")
                                    st.info(f"üìä **Macro Dashboard:** {format_currency(macro_total)} (diferen√ßa: {format_currency(abs(macro_total - excel_target))})")
                                    st.info(f"üî¨ **Micro Analysis:** {format_currency(total_operational_costs)} (diferen√ßa: {format_currency(abs(total_operational_costs - excel_target))})")
                                    
                                    if abs(macro_total - total_operational_costs) < 100:  # Allow small rounding differences
                                        st.success("üéØ **PERFEITO!** Micro analysis agora coincide com o Dashboard Macro!")
                                        
                                        if abs(macro_total - excel_target) < 1000:
                                            st.success("‚úÖ **EXCELENTE!** Ambos coincidem com o Excel!")
                                        else:
                                            st.error(f"‚ùå **PROBLEMA RAIZ:** Macro Dashboard n√£o est√° extraindo corretamente do Excel. Diferen√ßa de {format_currency(abs(macro_total - excel_target))}")
                                    else:
                                        st.warning(f"‚ö†Ô∏è Diferen√ßa Macro vs Micro: {format_currency(abs(macro_total - total_operational_costs))}")
                                        
                                    # Show detailed breakdown from macro
                                    st.write("**üîç Detalhes do Macro Dashboard:**")
                                    st.write(f"  - Custos Fixos: {format_currency(macro_fixed)}")
                                    st.write(f"  - Custos Vari√°veis: {format_currency(macro_variable)}")
                                    st.write(f"  - **TOTAL:** {format_currency(macro_total)}")
                                    
                                    if macro_total > excel_target:
                                        st.error("üö® **O extrator padr√£o est√° capturando custos a mais do que deveria!**")
                                        st.info("üí° Poss√≠vel causa: Est√° somando receitas ou resultados junto com custos")
                                    elif macro_total < excel_target:
                                        st.warning("‚ö†Ô∏è **O extrator padr√£o est√° perdendo alguns custos do Excel**")
                                        st.info("üí° Poss√≠vel causa: N√£o est√° capturando todas as linhas de custos operacionais")
                        
                        # Force re-extraction button
                        if st.button("üîÑ For√ßar Re-extra√ß√£o de Dados (Debug)", key="force_reextract"):
                            # Clear all data caches
                            cache_keys = ['flexible_data', 'processed_data', 'hybrid_micro_data', 'detailed_monthly_data']
                            for key in cache_keys:
                                if hasattr(st.session_state, key):
                                    delattr(st.session_state, key)
                            st.success("Cache limpo! Por favor, v√° para a aba Upload e clique em 'Analisar Dados' novamente.")
                            st.info("Agora usando sistema h√≠brido: totais precisos do Macro + detalhes do Micro.")
                        
                        # Debug: Show breakdown by category
                        with st.expander("üîß Debug: Breakdown por Categoria", expanded=False):
                            category_totals = {}
                            for item in filtered_items:
                                cat = item['categoria']
                                if cat not in category_totals:
                                    category_totals[cat] = 0
                                category_totals[cat] += item['valor_anual']
                            
                            st.write("**Totais por categoria:**")
                            for cat, total in sorted(category_totals.items(), key=lambda x: x[1], reverse=True):
                                st.write(f"- {cat}: {format_currency(total)}")
                            
                            st.write(f"**Total de itens filtrados:** {len(filtered_items)}")
                            st.write(f"**Anos selecionados:** {selected_years}")
                            
                            # Compare with all_items
                            all_items_total = sum(item['valor_anual'] for item in all_items if str(item['ano']) in [str(y) for y in selected_years] and item['categoria'] != 'revenue')
                            st.write(f"**Total em all_items (mesmo ano, sem receita):** {format_currency(all_items_total)}")
                            st.write(f"**Total em filtered_items:** {format_currency(total_annual)}")
                            st.write(f"**Diferen√ßa:** {format_currency(all_items_total - total_annual)}")
                            
                            # Show what should be the real total from Excel
                            st.write("**üéØ Verifica√ß√£o contra Excel:**")
                            st.write("- Custos Operacionais no Excel (2025): R$ 1.683.000")
                            st.write(f"- Total extra√≠do pelo sistema: {format_currency(all_items_total)}")
                            st.write(f"- **DIFEREN√áA REAL:** {format_currency(1683000 - all_items_total)}")
                            
                            # Check if we have direct operational costs data
                            if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data:
                                macro_df = st.session_state.processed_data.get('consolidated', pd.DataFrame())
                                if not macro_df.empty and 2025 in macro_df['year'].values:
                                    row_2025 = macro_df[macro_df['year'] == 2025].iloc[0]
                                    fixed_costs_macro = row_2025.get('fixed_costs', 0)
                                    variable_costs_macro = row_2025.get('variable_costs', 0)
                                    total_macro = fixed_costs_macro + variable_costs_macro
                                    st.write(f"- **Dados Macro (Dashboard principal):** {format_currency(total_macro)}")
                                    st.write(f"  - Custos Fixos: {format_currency(fixed_costs_macro)}")
                                    st.write(f"  - Custos Vari√°veis: {format_currency(variable_costs_macro)}")
                                    
                                    if abs(total_macro - 1683000) < abs(all_items_total - 1683000):
                                        st.success("‚úÖ Os dados do Dashboard Macro est√£o mais pr√≥ximos do Excel!")
                                        st.info("üí° **Problema identificado:** O Micro est√° usando dados do extrator flex√≠vel que n√£o captura todos os custos operacionais do Excel.")
                                    else:
                                        st.warning("‚ö†Ô∏è Ambos os sistemas est√£o incorretos comparados ao Excel.")
                            
                            # Show some example items
                            st.write("**Exemplos de itens inclu√≠dos:**")
                            for item in filtered_items[:5]:
                                st.write(f"- {item['descricao']} ({item['categoria']}): {format_currency(item['valor_anual'])}")
                                
                            # Show what's being excluded
                            excluded_items = [item for item in all_items if str(item['ano']) in [str(y) for y in selected_years] and item['categoria'] != 'revenue' and item not in filtered_items]
                            if excluded_items:
                                st.write(f"**Itens exclu√≠dos ({len(excluded_items)}):**")
                                for item in excluded_items[:5]:
                                    st.write(f"- {item['descricao']} ({item['categoria']}): {format_currency(item['valor_anual'])}")
                            
                            # Show current classification issues
                            st.write("**üîç An√°lise de Classifica√ß√£o (Sistema H√≠brido):**")
                            other_items = [item for item in filtered_items if item['categoria'] == 'other']
                            if other_items:
                                st.write(f"‚ùå {len(other_items)} itens ainda classificados como 'other':")
                                for item in other_items[:10]:
                                    st.write(f"  - {item['descricao']}: {format_currency(item['valor_anual'])}")
                            else:
                                st.write("‚úÖ Nenhum item classificado como 'other' - sistema h√≠brido funcionando!")
                            
                            fixed_items = [item for item in filtered_items if item['categoria'] == 'fixed_costs']
                            variable_items = [item for item in filtered_items if item['categoria'] == 'variable_costs']
                            st.write(f"‚úÖ {len(fixed_items)} itens classificados como 'fixed_costs'")
                            st.write(f"‚úÖ {len(variable_items)} itens classificados como 'variable_costs'")
                            
                            # Show hybrid system status
                            if hasattr(st.session_state, 'hybrid_micro_data'):
                                st.write("üéØ **Status:** Sistema h√≠brido ativo - usando totais precisos do Dashboard Macro")
                            else:
                                st.write("‚ö†Ô∏è **Status:** Sistema h√≠brido n√£o inicializado")
                        
                        summary_cols = st.columns(5)
                            
                        with summary_cols[0]:
                            # Biggest single expense
                            if filtered_items:
                                biggest_expense = max(filtered_items, key=lambda x: x['valor_anual'])
                                st.metric(
                                    "üîù Maior Gasto",
                                    format_currency(biggest_expense['valor_anual']),
                                    biggest_expense['descricao'][:20] + "..."
                                )
                            else:
                                st.metric("üîù Maior Gasto", "N/A", "")
                                
                        with summary_cols[1]:
                            # Average expense
                            avg_expense = total_annual / len(filtered_items) if filtered_items else 0
                            st.metric(
                                "üìä M√©dia",
                                format_currency(avg_expense),
                                "por item"
                            )
                            
                        with summary_cols[2]:
                            # Growth indicator
                            if len(selected_years) > 1:
                                prev_year_items = [item for item in all_items if str(item['ano']) == str(selected_years[-2])]
                                prev_total = sum(item['valor_anual'] for item in prev_year_items)
                                growth = ((total_annual - prev_total) / prev_total * 100) if prev_total > 0 else 0
                                st.metric(
                                    "üìà Crescimento",
                                    f"{growth:+.1f}%",
                                    "vs ano anterior"
                                )
                            else:
                                st.metric("üìà Crescimento", "N/A", "Selecione 2 anos")
                                
                        with summary_cols[3]:
                            # Concentration
                            top_10_expenses = sorted(filtered_items, key=lambda x: x['valor_anual'], reverse=True)[:10]
                            top_10_total = sum(item['valor_anual'] for item in top_10_expenses)
                            concentration = (top_10_total / total_annual * 100) if total_annual > 0 else 0
                            st.metric(
                                "üéØ Concentra√ß√£o",
                                f"{concentration:.0f}%",
                                "nos top 10 itens"
                            )
                            
                        with summary_cols[4]:
                            # Breakdown by expense categories (admin, operational, marketing, etc)
                            expense_categories = {}
                            for item in filtered_items:
                                if item['categoria'] not in ['variable_costs', 'fixed_costs']:
                                    cat = item['categoria']
                                    if cat not in expense_categories:
                                        expense_categories[cat] = 0
                                    expense_categories[cat] += item['valor_anual']
                            
                            if expense_categories:
                                # Find the largest expense category
                                largest_cat = max(expense_categories.items(), key=lambda x: x[1])
                                cat_name = get_category_name(largest_cat[0])
                                cat_pct = (largest_cat[1] / other_costs_total * 100) if other_costs_total > 0 else 0
                                st.metric(
                                    "üìä Maior Categoria",
                                    f"{cat_name}",
                                    f"{cat_pct:.0f}% das despesas"
                                )
                            else:
                                st.metric("üìä Categorias", "N/A", "")
                        
                        # Actionable Insights Section
                        st.markdown("---")
                        st.markdown("### üí° Insights Acion√°veis")
                        
                        if analysis_mode == "üèÜ Maiores Gastos":
                            # Show top expenses with reduction opportunities
                            st.info("üéØ **Foco:** Seus maiores gastos - onde pequenas otimiza√ß√µes geram grandes economias")
                            
                            top_expenses = sorted(filtered_items, key=lambda x: x['valor_anual'], reverse=True)[:20]
                            
                            # Group similar expenses
                            expense_groups = {}
                            for item in top_expenses:
                                # Try to group by keywords in description
                                key_words = item['descricao'].lower().split()
                                group_key = None
                                
                                # Common grouping patterns
                                if any(word in key_words for word in ['sal√°rio', 'salario', 'funcion√°rio', 'funcionario']):
                                    group_key = "Folha de Pagamento"
                                elif any(word in key_words for word in ['vale', 'alimenta√ß√£o', 'refei√ß√£o']):
                                    group_key = "Benef√≠cios Alimenta√ß√£o"
                                elif any(word in key_words for word in ['aluguel', 'loca√ß√£o']):
                                    group_key = "Alugu√©is e Loca√ß√µes"
                                elif any(word in key_words for word in ['energia', 'luz', 'el√©trica']):
                                    group_key = "Energia El√©trica"
                                elif any(word in key_words for word in ['telefone', 'internet', 'telecom']):
                                    group_key = "Telecomunica√ß√µes"
                                else:
                                    group_key = item['subcategoria_principal_nome']
                                
                                if group_key not in expense_groups:
                                    expense_groups[group_key] = []
                                expense_groups[group_key].append(item)
                            
                            # Show expense groups
                            for group_name, items in sorted(expense_groups.items(), key=lambda x: sum(item['valor_anual'] for item in x[1]), reverse=True):
                                group_total = sum(item['valor_anual'] for item in items)
                                group_pct = (group_total / total_annual * 100) if total_annual > 0 else 0
                                
                                with st.expander(f"**{group_name}** - {format_currency(group_total)} ({group_pct:.1f}% do total)", expanded=True):
                                    for item in sorted(items, key=lambda x: x['valor_anual'], reverse=True):
                                        col1, col2, col3 = st.columns([4, 2, 2])
                                        with col1:
                                            st.write(f"‚Ä¢ {item['descricao']}")
                                        with col2:
                                            st.write(format_currency(item['valor_anual']))
                                        with col3:
                                            # Show trend
                                            months_active = sum(1 for v in item['valores_mensais'].values() if v > 0)
                                            if months_active >= 10:
                                                st.write("üîÑ Recorrente")
                                            else:
                                                st.write(f"üìÖ {months_active} meses")
                        
                        elif analysis_mode == "üìà Crescimento R√°pido":
                            st.info("üìà **Foco:** Despesas crescendo rapidamente - controle antes que saiam de controle")
                            
                            # Compare with previous year
                            if len(selected_years) > 1:
                                growth_analysis = []
                                current_year_str = str(selected_years[-1])
                                prev_year_str = str(selected_years[-2])
                                
                                # Get items from both years
                                current_items_dict = {item['descricao']: item for item in all_items if str(item['ano']) == current_year_str}
                                prev_items_dict = {item['descricao']: item for item in all_items if str(item['ano']) == prev_year_str}
                                
                                # Calculate growth
                                for desc, current_item in current_items_dict.items():
                                    if desc in prev_items_dict:
                                        prev_value = prev_items_dict[desc]['valor_anual']
                                        current_value = current_item['valor_anual']
                                        if prev_value > 0:
                                            growth = ((current_value - prev_value) / prev_value) * 100
                                            growth_analysis.append({
                                                'item': current_item,
                                                'prev_value': prev_value,
                                                'growth': growth,
                                                'growth_amount': current_value - prev_value
                                            })
                                
                                # Sort by growth rate
                                fast_growing = sorted([x for x in growth_analysis if x['growth'] > 10], 
                                                    key=lambda x: x['growth'], reverse=True)[:20]
                                
                                if fast_growing:
                                    for analysis in fast_growing:
                                        item = analysis['item']
                                        col1, col2, col3, col4 = st.columns([3, 2, 2, 2])
                                        with col1:
                                            st.write(f"‚Ä¢ **{item['descricao']}**")
                                        with col2:
                                            st.metric("Atual", format_currency(item['valor_anual']))
                                        with col3:
                                            st.metric("Crescimento", f"{analysis['growth']:.0f}%", 
                                                    f"+{format_currency(analysis['growth_amount'])}")
                                        with col4:
                                            if analysis['growth'] > 50:
                                                st.error("‚ö†Ô∏è Aten√ß√£o!")
                                            elif analysis['growth'] > 25:
                                                st.warning("‚ö° Monitorar")
                                            else:
                                                st.success("‚úì Normal")
                                else:
                                    st.success("‚úÖ Nenhuma despesa com crescimento preocupante!")
                            else:
                                st.warning("‚ö†Ô∏è Selecione pelo menos 2 anos para an√°lise de crescimento")
                        
                        elif analysis_mode == "üîÑ Custos Recorrentes":
                            st.info("üîÑ **Foco:** Despesas mensais fixas - oportunidades de renegocia√ß√£o e consolida√ß√£o")
                            
                            # Find recurring expenses (present in 10+ months)
                            recurring_expenses = []
                            for item in filtered_items:
                                months_with_value = sum(1 for v in item['valores_mensais'].values() if v > 0)
                                if months_with_value >= 10:
                                    monthly_avg = item['valor_anual'] / months_with_value
                                    recurring_expenses.append({
                                        'item': item,
                                        'months_active': months_with_value,
                                        'monthly_avg': monthly_avg
                                    })
                            
                            # Sort by monthly average
                            recurring_sorted = sorted(recurring_expenses, key=lambda x: x['monthly_avg'], reverse=True)
                            
                            # Group by type
                            recurring_groups = {
                                "Folha de Pagamento": [],
                                "Infraestrutura": [],
                                "Servi√ßos": [],
                                "Benef√≠cios": [],
                                "Outros": []
                            }
                            
                            for rec in recurring_sorted:
                                item = rec['item']
                                desc_lower = item['descricao'].lower()
                                
                                if any(word in desc_lower for word in ['sal√°rio', 'funcion√°rio', 'folha']):
                                    recurring_groups["Folha de Pagamento"].append(rec)
                                elif any(word in desc_lower for word in ['aluguel', 'energia', '√°gua', 'condom√≠nio']):
                                    recurring_groups["Infraestrutura"].append(rec)
                                elif any(word in desc_lower for word in ['internet', 'telefone', 'software', 'sistema']):
                                    recurring_groups["Servi√ßos"].append(rec)
                                elif any(word in desc_lower for word in ['vale', 'benef√≠cio', 'plano']):
                                    recurring_groups["Benef√≠cios"].append(rec)
                                else:
                                    recurring_groups["Outros"].append(rec)
                            
                            # Show groups
                            for group_name, items in recurring_groups.items():
                                if items:
                                    group_monthly = sum(item['monthly_avg'] for item in items)
                                    group_annual = sum(item['item']['valor_anual'] for item in items)
                                    
                                    with st.expander(f"**{group_name}** - {format_currency(group_monthly)}/m√™s ({len(items)} itens)", expanded=True):
                                        st.caption(f"Total anual: {format_currency(group_annual)}")
                                        
                                        for rec in items[:10]:  # Show top 10
                                            item = rec['item']
                                            col1, col2, col3 = st.columns([4, 2, 2])
                                            with col1:
                                                st.write(f"‚Ä¢ {item['descricao']}")
                                            with col2:
                                                st.write(f"{format_currency(rec['monthly_avg'])}/m√™s")
                                            with col3:
                                                st.write(f"‚úì {rec['months_active']} meses")
                        
                        elif analysis_mode == "üí° Oportunidades":
                            st.info("üí° **Foco:** Oportunidades de economia identificadas automaticamente")
                            
                            opportunities = []
                            
                            # 1. Duplicate or similar expenses
                            descriptions = {}
                            for item in filtered_items:
                                # Normalize description
                                key_words = sorted(item['descricao'].lower().split()[:3])  # First 3 words
                                key = ' '.join(key_words)
                                if key not in descriptions:
                                    descriptions[key] = []
                                descriptions[key].append(item)
                            
                            # Find potential duplicates
                            for key, items in descriptions.items():
                                if len(items) > 1:
                                    total = sum(item['valor_anual'] for item in items)
                                    opportunities.append({
                                        'type': 'Poss√≠vel Duplica√ß√£o',
                                        'description': f"{len(items)} despesas similares: {items[0]['descricao'][:30]}...",
                                        'saving': total * 0.1,  # Assume 10% saving potential
                                        'items': items
                                    })
                            
                            # 2. Expenses that vary significantly month to month
                            for item in filtered_items:
                                monthly_values = [v for v in item['valores_mensais'].values() if v > 0]
                                if len(monthly_values) >= 6:
                                    avg = sum(monthly_values) / len(monthly_values)
                                    std_dev = (sum((v - avg) ** 2 for v in monthly_values) / len(monthly_values)) ** 0.5
                                    cv = std_dev / avg if avg > 0 else 0  # Coefficient of variation
                                    
                                    if cv > 0.5:  # High variation
                                        opportunities.append({
                                            'type': 'Alta Varia√ß√£o',
                                            'description': f"{item['descricao']} - varia muito m√™s a m√™s",
                                            'saving': item['valor_anual'] * 0.15,
                                            'items': [item]
                                        })
                            
                            # 3. Small recurring expenses that add up
                            small_recurring = [item for item in filtered_items 
                                             if item['valor_anual'] < 5000 and 
                                             sum(1 for v in item['valores_mensais'].values() if v > 0) >= 10]
                            
                            if len(small_recurring) > 5:
                                total_small = sum(item['valor_anual'] for item in small_recurring)
                                opportunities.append({
                                    'type': 'Pequenas Despesas',
                                    'description': f"{len(small_recurring)} pequenas despesas recorrentes",
                                    'saving': total_small * 0.2,
                                    'items': small_recurring
                                })
                            
                            # Sort opportunities by saving potential
                            opportunities_sorted = sorted(opportunities, key=lambda x: x['saving'], reverse=True)[:10]
                            
                            total_saving_potential = sum(opp['saving'] for opp in opportunities_sorted)
                            
                            if opportunities_sorted:
                                st.success(f"üéØ **Potencial de economia identificado: {format_currency(total_saving_potential)}/ano**")
                                
                                for i, opp in enumerate(opportunities_sorted, 1):
                                    with st.expander(f"{i}. {opp['type']} - Economia potencial: {format_currency(opp['saving'])}", expanded=(i <= 3)):
                                        st.write(f"**{opp['description']}**")
                                        
                                        # Show items
                                        for item in opp['items'][:5]:
                                            col1, col2 = st.columns([3, 1])
                                            with col1:
                                                st.write(f"‚Ä¢ {item['descricao']}")
                                            with col2:
                                                st.write(format_currency(item['valor_anual']))
                                        
                                        if len(opp['items']) > 5:
                                            st.caption(f"... e {len(opp['items']) - 5} mais")
                                        
                                        # Action suggestion
                                        if opp['type'] == 'Poss√≠vel Duplica√ß√£o':
                                            st.info("üí° **A√ß√£o:** Revisar se s√£o realmente necess√°rias todas essas despesas similares")
                                        elif opp['type'] == 'Alta Varia√ß√£o':
                                            st.info("üí° **A√ß√£o:** Negociar contrato fixo ou investigar causas da varia√ß√£o")
                                        elif opp['type'] == 'Pequenas Despesas':
                                            st.info("üí° **A√ß√£o:** Consolidar fornecedores ou cancelar servi√ßos n√£o essenciais")
                            else:
                                st.success("‚úÖ Estrutura de custos otimizada - poucas oportunidades √≥bvias de economia")
                        
                        # Filters have been moved to the top of the page for better UX
                        
                        # Build available subcategories for filtering
                        available_subcategories = []
                        for main_cat in selected_main_categories:
                            if main_cat in subcategories_data:
                                for sub_cat in subcategories_data[main_cat]['subcategories'].keys():
                                    available_subcategories.append(f"{main_cat}_{sub_cat}")
                            elif main_cat == 'outros':
                                available_subcategories.append('outros_nao_categorizado')
                        
                        # Apply all filters
                        filtered_items = []
                        for item in detailed_data['line_items']:
                            # Exclude revenue items completely
                            if item['categoria'] == 'revenue':
                                continue
                                
                            # Year filter - convert to string for comparison
                            if str(item['ano']) not in [str(y) for y in selected_years]:
                                continue
                            
                            # Category filter
                            if item['categoria'] not in selected_categories:
                                continue
                            
                            # Subcategory filter (only if advanced filters expanded)
                            if 'selected_main_categories' in locals():
                                item_subcat_key = f"{item['subcategoria_principal']}_{item['subcategoria']}"
                                if item_subcat_key not in available_subcategories:
                                    continue
                            
                            # Month filter - use selected_months from the reusable filter
                            if selected_months:
                                # Check if item has any value in selected months
                                has_value_in_month = any(
                                    item['valores_mensais'].get(month, 0) > 0 
                                    for month in selected_months
                                )
                                if not has_value_in_month:
                                    continue
                            
                            # Value filter (only if advanced filters expanded)
                            if 'min_value' in locals():
                                if not (min_value <= item['valor_anual'] <= max_value):
                                    continue
                            
                            # Search filter
                            if search_term:
                                search_words = search_term.lower().split()
                                item_desc_lower = item['descricao'].lower()
                                if not any(word in item_desc_lower for word in search_words):
                                    continue
                            
                            filtered_items.append(item)
                        
                        # Debug info (temporary)
                        if len(filtered_items) == 0 and detailed_data['line_items']:
                            with st.expander("üîç Debug: Por que n√£o h√° itens?", expanded=False):
                                st.write(f"Total de itens antes dos filtros: {len(detailed_data['line_items'])}")
                                st.write(f"Anos selecionados: {selected_years}")
                                st.write(f"Meses selecionados: {st.session_state.details_month_filter if hasattr(st.session_state, 'details_month_filter') else 'Todos'}")
                                st.write(f"Categorias selecionadas: {len(selected_categories)} de {len(all_categories)}")
                                
                                # Check year distribution
                                year_counts = {}
                                for item in detailed_data['line_items']:
                                    year = item['ano']
                                    year_counts[year] = year_counts.get(year, 0) + 1
                                st.write(f"Distribui√ß√£o por ano: {year_counts}")
                        
                        # Summary metrics after filtering
                        st.markdown("---")
                        summary_cols = st.columns(5)
                        
                        total_filtered = sum(item['valor_anual'] for item in filtered_items)
                        unique_descriptions = len(set(item['descricao'] for item in filtered_items))
                        
                        with summary_cols[0]:
                            st.metric("üí∞ Total", format_currency(total_filtered))
                        with summary_cols[1]:
                            st.metric("üìã Itens", f"{len(filtered_items):,}")
                        with summary_cols[2]:
                            st.metric("üè∑Ô∏è √önicos", f"{unique_descriptions:,}")
                        with summary_cols[3]:
                            avg_value = total_filtered / len(filtered_items) if filtered_items else 0
                            st.metric("üìä M√©dia", format_currency(avg_value))
                        with summary_cols[4]:
                            # Comparison with previous period if multiple years selected
                            if len(selected_years) > 1:
                                prev_year_total = sum(item['valor_anual'] for item in filtered_items 
                                                    if item['ano'] == selected_years[-2])
                                curr_year_total = sum(item['valor_anual'] for item in filtered_items 
                                                    if item['ano'] == selected_years[-1])
                                if prev_year_total > 0:
                                    growth = ((curr_year_total - prev_year_total) / prev_year_total) * 100
                                    st.metric("üìà Varia√ß√£o", f"{growth:+.1f}%")
                                else:
                                    st.metric("üìà Varia√ß√£o", "N/A")
                            else:
                                st.metric("üìà Varia√ß√£o", "Selecione 2+ anos")
                    
                        # Visualizations Section
                        st.markdown("---")
                        st.markdown("### üìä An√°lises Visuais")
                        
                        # Create simplified visualization tabs
                        viz_tab1, viz_tab2 = st.tabs([
                            "üìä Visualiza√ß√£o Detalhada",
                            "üìà An√°lise Temporal"
                        ])
                    
                        # Tab 1: Detailed View
                        with viz_tab1:
                            if filtered_items:
                                # Show filtered items in a clean table format
                                st.markdown(f"#### üìã Lista Detalhada - {len(filtered_items)} itens")
                                
                                # Add sorting options
                                sort_col1, sort_col2 = st.columns([1, 3])
                                with sort_col1:
                                    sort_by = st.selectbox(
                                        "Ordenar por",
                                        ["Valor (Maior ‚Üí Menor)", "Valor (Menor ‚Üí Maior)", "Alfab√©tica", "Categoria"],
                                        key="micro_sort"
                                    )
                                
                                # Sort items based on selection
                                if sort_by == "Valor (Maior ‚Üí Menor)":
                                    sorted_items = sorted(filtered_items, key=lambda x: x['valor_anual'], reverse=True)
                                elif sort_by == "Valor (Menor ‚Üí Maior)":
                                    sorted_items = sorted(filtered_items, key=lambda x: x['valor_anual'])
                                elif sort_by == "Alfab√©tica":
                                    sorted_items = sorted(filtered_items, key=lambda x: x['descricao'])
                                else:  # By category
                                    sorted_items = sorted(filtered_items, key=lambda x: (x['categoria'], x['valor_anual']), reverse=True)
                                
                                # Display limit
                                display_limit = 50 if len(sorted_items) > 50 else len(sorted_items)
                                if len(sorted_items) > 50:
                                    st.info(f"Mostrando top {display_limit} de {len(sorted_items)} itens. Use os filtros para refinar.")
                                
                                # Create clean item list
                                for idx, item in enumerate(sorted_items[:display_limit]):
                                    with st.container():
                                        col1, col2, col3, col4 = st.columns([0.5, 4, 2, 1.5])
                                        
                                        with col1:
                                            st.write(f"**{idx+1}**")
                                        
                                        with col2:
                                            st.write(f"**{item['descricao']}**")
                                            st.caption(f"{get_category_name(item['categoria'])}")
                                        
                                        with col3:
                                            st.metric("Valor Anual", format_currency(item['valor_anual']))
                                        
                                        with col4:
                                            # Recurrence indicator
                                            months_active = sum(1 for v in item['valores_mensais'].values() if v > 0)
                                            if months_active >= 10:
                                                st.success("üîÑ Recorrente")
                                            elif months_active >= 6:
                                                st.warning(f"üìÖ {months_active} meses")
                                            else:
                                                st.info(f"üìÖ {months_active} meses")
                                    
                                    if idx < display_limit - 1:
                                        st.divider()
                                
                                # Option to export data
                                if st.button("üì• Exportar Dados Filtrados", key="export_details"):
                                    # Create DataFrame for export
                                    export_data = []
                                    for item in filtered_items:
                                        export_data.append({
                                            'Ano': item['ano'],
                                            'Categoria': get_category_name(item['categoria']),
                                            'Subcategoria': f"{item['subcategoria_principal_nome']} - {item['subcategoria_nome']}",
                                            'Descri√ß√£o': item['descricao'],
                                            'Valor Anual': item['valor_anual']
                                        })
                                    
                                    export_df = pd.DataFrame(export_data)
                                    csv = export_df.to_csv(index=False)
                                    st.download_button(
                                        label="üìÑ Baixar CSV",
                                        data=csv,
                                        file_name=f"despesas_detalhadas_{current_year}.csv",
                                        mime="text/csv"
                                    )
                            else:
                                st.info("Nenhum item encontrado com os filtros selecionados")
                        
                        # Tab 2: Temporal Analysis
                        with viz_tab2:
                            if filtered_items and st.session_state.get('flexible_data'):
                                st.markdown("#### üìà Evolu√ß√£o Temporal das Despesas")
                                
                                # Get monthly data for temporal analysis
                                flexible_data = st.session_state.flexible_data
                                
                                # Time range selector
                                time_col1, time_col2 = st.columns([2, 3])
                                with time_col1:
                                    time_view = st.radio(
                                        "Visualiza√ß√£o temporal",
                                        ["Mensal", "Trimestral", "Anual"],
                                        key="micro_time_view"
                                    )
                                
                                # Prepare temporal data
                                temporal_data = []
                                months = ['JAN', 'FEV', 'MAR', 'ABR', 'MAI', 'JUN', 
                                         'JUL', 'AGO', 'SET', 'OUT', 'NOV', 'DEZ']
                                
                                # Collect data for selected items across time
                                selected_items_keys = [item.get('key', item.get('item_id', f"{item['ano']}_{item['descricao'][:20]}")) for item in filtered_items[:10]]  # Top 10 items
                                
                                for year in sorted(flexible_data.keys()):
                                    if year in selected_years:
                                        year_data = flexible_data[year].get('line_items', {})
                                        
                                        if time_view == "Mensal":
                                            for month_idx, month in enumerate(months):
                                                month_total = 0
                                                for item_key in selected_items_keys:
                                                    if item_key in year_data:
                                                        month_value = year_data[item_key].get(month, 0)
                                                        month_total += month_value
                                                
                                                if month_total > 0:
                                                    temporal_data.append({
                                                        'date': pd.Timestamp(year, month_idx + 1, 1),
                                                        'value': month_total,
                                                        'period': f"{month}/{year}"
                                                    })
                                        
                                        elif time_view == "Trimestral":
                                            quarters = {
                                                'Q1': ['JAN', 'FEV', 'MAR'],
                                                'Q2': ['ABR', 'MAI', 'JUN'],
                                                'Q3': ['JUL', 'AGO', 'SET'],
                                                'Q4': ['OUT', 'NOV', 'DEZ']
                                            }
                                            for q_name, q_months in quarters.items():
                                                quarter_total = 0
                                                for item_key in selected_items_keys:
                                                    if item_key in year_data:
                                                        for month in q_months:
                                                            quarter_total += year_data[item_key].get(month, 0)
                                                
                                                if quarter_total > 0:
                                                    q_num = int(q_name[1])
                                                    temporal_data.append({
                                                        'date': pd.Timestamp(year, q_num * 3 - 2, 1),
                                                        'value': quarter_total,
                                                        'period': f"{q_name}/{year}"
                                                    })
                                        
                                        else:  # Anual
                                            year_total = sum(item['valor_anual'] for item in filtered_items 
                                                           if item.get('key', item.get('item_id', f"{item['ano']}_{item['descricao'][:20]}")) in selected_items_keys)
                                            if year_total > 0:
                                                temporal_data.append({
                                                    'date': pd.Timestamp(year, 1, 1),
                                                    'value': year_total,
                                                    'period': str(year)
                                                })
                                
                                if temporal_data:
                                    # Create temporal DataFrame
                                    temporal_df = pd.DataFrame(temporal_data).sort_values('date')
                                    
                                    # Create line chart
                                    fig_temporal = go.Figure()
                                    
                                    fig_temporal.add_trace(go.Scatter(
                                        x=temporal_df['date'],
                                        y=temporal_df['value'],
                                        mode='lines+markers',
                                        name='Total de Despesas',
                                        line=dict(color='blue', width=3),
                                        marker=dict(size=8),
                                        text=temporal_df['period'],
                                        hovertemplate='<b>%{text}</b><br>Valor: R$ %{y:,.2f}<extra></extra>'
                                    ))
                                    
                                    # Add trend line
                                    if len(temporal_df) > 3:
                                        z = np.polyfit(range(len(temporal_df)), temporal_df['value'], 1)
                                        p = np.poly1d(z)
                                        fig_temporal.add_trace(go.Scatter(
                                            x=temporal_df['date'],
                                            y=p(range(len(temporal_df))),
                                            mode='lines',
                                            name='Tend√™ncia',
                                            line=dict(color='red', width=2, dash='dash')
                                        ))
                                    
                                    fig_temporal.update_layout(
                                        title=f"Evolu√ß√£o {time_view} das Top 10 Despesas",
                                        xaxis_title="Per√≠odo",
                                        yaxis_title="Valor (R$)",
                                        height=500,
                                        hovermode='x',
                                        showlegend=True
                                    )
                                    
                                    st.plotly_chart(fig_temporal, use_container_width=True)
                                    
                                    # Show insights
                                    col_insight1, col_insight2 = st.columns(2)
                                    
                                    with col_insight1:
                                        # Calculate growth
                                        if len(temporal_df) > 1:
                                            first_value = temporal_df.iloc[0]['value']
                                            last_value = temporal_df.iloc[-1]['value']
                                            growth = ((last_value - first_value) / first_value) * 100
                                            
                                            if growth > 0:
                                                st.metric(
                                                    "Crescimento Total",
                                                    f"{growth:.1f}%",
                                                    delta="‚Üë Aumento",
                                                    delta_color="inverse"
                                                )
                                            else:
                                                st.metric(
                                                    "Crescimento Total",
                                                    f"{growth:.1f}%",
                                                    delta="‚Üì Redu√ß√£o",
                                                    delta_color="normal"
                                                )
                                    
                                    with col_insight2:
                                        # Average value
                                        avg_value = temporal_df['value'].mean()
                                        st.metric(
                                            f"M√©dia {time_view}",
                                            format_currency(avg_value)
                                        )
                                    
                                    # Seasonality analysis for monthly view
                                    if time_view == "Mensal" and len(temporal_df) >= 12:
                                        st.markdown("##### üìä An√°lise de Sazonalidade")
                                        
                                        # Calculate average by month
                                        temporal_df['month'] = temporal_df['date'].dt.month
                                        monthly_avg = temporal_df.groupby('month')['value'].mean()
                                        
                                        # Create seasonality chart
                                        fig_season = go.Figure()
                                        
                                        fig_season.add_trace(go.Bar(
                                            x=months,
                                            y=[monthly_avg.get(i+1, 0) for i in range(12)],
                                            marker_color=['red' if monthly_avg.get(i+1, 0) > monthly_avg.mean() else 'lightblue' 
                                                         for i in range(12)],
                                            text=[format_currency(monthly_avg.get(i+1, 0)) for i in range(12)],
                                            textposition='outside',
                                            hovertemplate='<b>%{x}</b><br>M√©dia: %{text}<extra></extra>'
                                        ))
                                        
                                        fig_season.add_hline(
                                            y=monthly_avg.mean(),
                                            line_dash="dash",
                                            line_color="gray",
                                            annotation_text=f"M√©dia Geral: {format_currency(monthly_avg.mean())}"
                                        )
                                        
                                        fig_season.update_layout(
                                            title="Padr√£o de Sazonalidade",
                                            xaxis_title="M√™s",
                                            yaxis_title="Valor M√©dio (R$)",
                                            height=400,
                                            showlegend=False
                                        )
                                        
                                        st.plotly_chart(fig_season, use_container_width=True)
                                        
                                        # Identify peak months
                                        peak_months = [months[i] for i in range(12) 
                                                      if monthly_avg.get(i+1, 0) > monthly_avg.mean() * 1.1]
                                        if peak_months:
                                            st.info(f"üìà **Meses de pico**: {', '.join(peak_months)}")
                                
                                else:
                                    st.info("üìä N√£o h√° dados temporais suficientes para an√°lise")
                            else:
                                st.info("üìä Selecione despesas para visualizar a evolu√ß√£o temporal")
                    # Close the details section
                    else:
                        st.info("üëÜ Carregue arquivos na aba 'Upload' primeiro.")
                else:
                    st.info("üëÜ Please upload files in the 'Upload' tab first.")

        # Tab 3/4: AI Insights
        tab_ai = tab4 if use_flexible_extractor else tab3
        with tab_ai:
            st.header("ü§ñ Insights com Gemini AI")
    
            # Load extracted data from database if not in session state
            if not hasattr(st.session_state, 'extracted_data') or not st.session_state.extracted_data:
                st.session_state.extracted_data = db.load_all_financial_data()
    
            if hasattr(st.session_state, 'processed_data') and st.session_state.processed_data is not None and gemini_api_key:
                if st.button("ü§ñ Generate AI Business Insights", type="primary"):
                    with st.spinner("Analyzing data with AI... Please wait..."):
                        try:
                            # Configure Gemini
                            genai.configure(api_key=gemini_api_key)
                            model = genai.GenerativeModel('gemini-1.5-flash')
                    
                            # Prepare data for analysis
                            df = st.session_state.processed_data.get('consolidated', pd.DataFrame())
                            if not isinstance(df, pd.DataFrame):
                                df = pd.DataFrame()
                            summary = st.session_state.processed_data.get('summary', {})
                            
                            # Include flexible data insights
                            flexible_summary = ""
                            if hasattr(st.session_state, 'flexible_data') and st.session_state.flexible_data:
                                all_categories = set()
                                all_items = set()
                                for year_data in st.session_state.flexible_data.values():
                                    all_categories.update(year_data['categories'].keys())
                                    all_items.update(item['label'] for item in year_data['line_items'].values())
                                
                                flexible_summary = f"\n\nDetected categories: {len(all_categories)}\nTotal data lines: {len(all_items)}"
                            
                            # Create prompt with language instruction based on user selection
                            if language == "Portugu√™s":
                                language_instruction = "INSTRU√á√ÉO CR√çTICA: Voc√™ DEVE responder inteiramente em portugu√™s brasileiro. N√ÉO use palavras ou frases em ingl√™s."
                                analysis_request = "Por favor, analise os seguintes dados financeiros da Marine Seguros e forne√ßa insights detalhados de neg√≥cios:"
                            else:
                                language_instruction = "CRITICAL INSTRUCTION: You MUST respond entirely in English. Do NOT use Portuguese words or phrases."
                                analysis_request = "Please analyze the following financial data from Marine Seguros and provide detailed business insights:"
                            
                            prompt = f"""
                            {language_instruction}
                            
                            {analysis_request}
                            
                            Summary Data:
                            - Period: {summary.get('years_range', 'N/A')}
                            - Total Revenue: R$ {summary.get('metrics', {}).get('revenue', {}).get('total', 0):,.2f}
                            - Revenue CAGR: {summary.get('metrics', {}).get('revenue', {}).get('cagr', 0):.1f}%
                            - Average Profit Margin: {summary.get('metrics', {}).get('profit_margin', {}).get('average', 0):.1f}%
                            {flexible_summary}
                            
                            Annual Data:
                            {df.to_string() if not df.empty else 'No data available'}
                            
                            {
                                "Por favor, forne√ßa uma an√°lise abrangente cobrindo:" if language == "Portugu√™s" else "Please provide a comprehensive analysis covering:"
                            }
                            {
                                '''1. **An√°lise das Principais Tend√™ncias Financeiras**
                            2. **Pontos Fortes de Performance & Vantagens Competitivas**
                            3. **√Åreas de Preocupa√ß√£o & Gest√£o de Riscos**
                            4. **Recomenda√ß√µes Acion√°veis para Crescimento**
                            5. **An√°lise Competitiva do Setor**
                            
                            Estruture sua resposta em um formato de relat√≥rio profissional com se√ß√µes claras, bullet points e recomenda√ß√µes espec√≠ficas.''' if language == "Portugu√™s" else 
                                '''1. **Key Financial Trends Analysis**
                            2. **Performance Strengths & Competitive Advantages**
                            3. **Areas of Concern & Risk Management**
                            4. **Actionable Recommendations for Growth**
                            5. **Industry Competitive Analysis**
                            
                            Structure your response in a professional report format with clear sections, bullet points, and specific recommendations.'''
                            }
                            """
                            
                            # Generate insights
                            response = model.generate_content(prompt)
                            
                            # Store in session state
                            st.session_state.gemini_insights = response.text
                            
                            # Display insights
                            st.markdown("### üìä Business Analysis Report")
                            st.markdown(response.text)
                            
                            # Save to database
                            db.auto_save_state(st.session_state)
                            
                        except Exception as e:
                            st.error(f"Error generating AI insights: {str(e)}")
                            st.info("Please check your Gemini API key in the sidebar.")
            
            elif not gemini_api_key:
                st.warning("‚ö†Ô∏è Please enter your Gemini API key in the sidebar to use AI insights.")
                st.info("You can get a free API key from [Google AI Studio](https://makersuite.google.com/app/apikey)")
            else:
                st.info("üëÜ Please upload files and process data in the 'Upload' tab first.")
        
